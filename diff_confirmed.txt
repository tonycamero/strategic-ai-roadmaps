diff --git a/backend/src/controllers/diagnosticRerun.controller.ts b/backend/src/controllers/diagnosticRerun.controller.ts
index 46cf532..1ec9b9d 100644
--- a/backend/src/controllers/diagnosticRerun.controller.ts
+++ b/backend/src/controllers/diagnosticRerun.controller.ts
@@ -130,8 +130,8 @@ export async function rerunSop01ForFirm(req: AuthRequest, res: Response, next: N
         if (process.env.DEBUG_TICKETS_PIPELINE === '1') {
             console.log('[DEBUG_TICKETS_PIPELINE] SOP-01 Outputs Generated:', {
                 diagnosticKeys: Object.keys(outputs),
-                diagnosticLength: outputs.companyDiagnosticMap?.length,
-                skeletonLength: outputs.roadmapSkeleton?.length
+                diagnosticLength: outputs.sop01DiagnosticMarkdown?.length,
+                skeletonLength: outputs.sop01RoadmapSkeletonMarkdown?.length
             });
         }
 
diff --git a/backend/src/controllers/superadmin.controller.ts b/backend/src/controllers/superadmin.controller.ts
index 602127b..963b3a8 100644
--- a/backend/src/controllers/superadmin.controller.ts
+++ b/backend/src/controllers/superadmin.controller.ts
@@ -1,5 +1,3 @@
-<<<<<<< HEAD
-<<<<<<< HEAD
 import { Response } from 'express';
 import { nanoid } from 'nanoid';
 import { db } from '../db';
@@ -13,13 +11,6 @@ import {
 } from '../db/schema';
 import { eq, and, sql, count, desc, asc } from 'drizzle-orm';
 import { randomUUID } from 'crypto';
-=======
-import { Response } from 'express';
-import { nanoid } from 'nanoid';
-import { db } from '../db';
-import { users, intakes, tenants, roadmaps, auditEvents, tenantDocuments, discoveryCallNotes, roadmapSections, ticketPacks, ticketInstances, tenantMetricsDaily, webinarRegistrations, implementationSnapshots, roadmapOutcomes, agentConfigs, agentThreads, webinarSettings, diagnostics, executiveBriefs } from '../db/schema';
-import { eq, and, sql, count, desc, asc } from 'drizzle-orm';
->>>>>>> 1e46cab (chore: lock executive brief render + pdf contracts)
 import { AuthRequest } from '../middleware/auth';
 import path from 'path';
 import fs from 'fs/promises';
@@ -30,7 +21,6 @@ import { getOrCreateRoadmapForTenant } from '../services/roadmapOs.service';
 import { refreshVectorStoreContent } from '../services/tenantVectorStore.service';
 import { getModerationStatus } from '../services/ticketModeration.service';
 import { AUDIT_EVENT_TYPES } from '../constants/auditEventTypes';
-<<<<<<< HEAD
 import { AuthorityCategory, CanonicalDiscoveryNotes } from '@roadmap/shared';
 import { generateRawTickets, ParsedTicket, InventoryEmptyError } from '../services/diagnosticIngestion.service';
 import { Sop01Outputs } from '../services/sop01Engine';
@@ -53,13 +43,6 @@ const UPLOADS_DIR = path.join(__dirname, '../../uploads');
 
 // ============================================================================
 // HELPER: Permissions & Authority
-=======
-import { AuthorityCategory } from '@roadmap/shared';
-const UPLOADS_DIR = path.join(__dirname, '../../uploads');
-
-// ============================================================================
-// HELPER: Check SuperAdmin Permission
->>>>>>> 1e46cab (chore: lock executive brief render + pdf contracts)
 // ============================================================================
 
 /**
@@ -100,7 +83,6 @@ function requireExecutiveAuthority(req: AuthRequest, res: Response): boolean {
 // GET /api/superadmin/overview - Global Dashboard Stats
 // ============================================================================
 
-<<<<<<< HEAD
 export async function getOverview(
   req: AuthRequest<any, any, any, { cohortLabel?: string }>,
   res: Response
@@ -127,21 +109,6 @@ export async function getOverview(
     // Count intake completions
     const intakeRes = await db.select({ totalIntakes: count() }).from(intakes);
     const totalIntakes = intakeRes?.[0]?.totalIntakes ?? 0;
-=======
-export async function getOverview(req: AuthRequest<any, any, any, { cohortLabel?: string }>, res: Response) {
-  try {
-    if (!requireSuperAdmin(req, res)) return;
-
-    // Count total tenants
-    const [{ totalFirms }] = await db
-      .select({ totalFirms: count() })
-      .from(tenants);
-
-    // Count intake completions
-    const [{ totalIntakes }] = await db
-      .select({ totalIntakes: count() })
-      .from(intakes);
->>>>>>> 1e46cab (chore: lock executive brief render + pdf contracts)
 
     // Count tenants by status
     const statusStats = await db
@@ -161,7 +128,6 @@ export async function getOverview(req: AuthRequest<any, any, any, { cohortLabel?
       .from(roadmaps)
       .groupBy(roadmaps.status);
 
-<<<<<<< HEAD
     // Drizzle will throw if any selected field is undefined.
     // These columns may not exist in some schema snapshots, so guard them.
     const pilotStageCol = (roadmaps as any).pilotStage;
@@ -194,37 +160,11 @@ export async function getOverview(req: AuthRequest<any, any, any, { cohortLabel?
     return res.json({
       totalFirms,
       totalIntakes,
-=======
-    // Count roadmaps by pilot stage (exclude nulls)
-    const pilotStats = await db
-      .select({
-        pilotStage: roadmaps.pilotStage,
-        count: count(),
-      })
-      .from(roadmaps)
-      .where(sql`${roadmaps.pilotStage} IS NOT NULL`)
-      .groupBy(roadmaps.pilotStage);
-
-    // Count by cohort
-    const cohortStats = await db
-      .select({
-        cohortLabel: tenants.cohortLabel,
-        count: count(),
-      })
-      .from(tenants)
-      .where(sql`${tenants.cohortLabel} IS NOT NULL`)
-      .groupBy(tenants.cohortLabel);
-
-    return res.json({
-      totalFirms: totalFirms || 0,
-      totalIntakes: totalIntakes || 0,
->>>>>>> 1e46cab (chore: lock executive brief render + pdf contracts)
       statusStats,
       roadmapStats,
       pilotStats,
       cohortStats,
     });
-<<<<<<< HEAD
   } catch (error: any) {
     console.error('Get overview error:', error?.message ?? error, error?.stack);
     return res
@@ -234,14 +174,6 @@ export async function getOverview(req: AuthRequest<any, any, any, { cohortLabel?
 }
 
 
-=======
-  } catch (error) {
-    console.error('Get overview error:', error);
-    return res.status(500).json({ error: 'Failed to fetch overview' });
-  }
-}
-
->>>>>>> 1e46cab (chore: lock executive brief render + pdf contracts)
 // ============================================================================
 // GET ACTIVITY FEED
 // ============================================================================
@@ -717,19 +649,15 @@ export async function closeIntakeWindow(req: AuthRequest<{ tenantId: string }>,
 // GET /api/superadmin/firms/:tenantId - Firm Detail
 // ============================================================================
 
-<<<<<<< HEAD
 // Import artifact type constant if available, or hardcode string to avoid circular deps if needed
 // const DISCOVERY_SYNTHESIS_ARTIFACT_TYPE = 'DISCOVERY_SYNTHESIS_V1';
 
-=======
->>>>>>> 1e46cab (chore: lock executive brief render + pdf contracts)
 export async function getFirmDetail(req: AuthRequest<{ tenantId: string }>, res: Response) {
   try {
     if (!requireSuperAdmin(req, res)) return;
 
     const { tenantId } = req.params;
 
-<<<<<<< HEAD
     // Fetch Executive Brief Status & Derive Phase
     const [execBrief] = await db
       .select({ status: executiveBriefs.status })
@@ -746,8 +674,6 @@ export async function getFirmDetail(req: AuthRequest<{ tenantId: string }>, res:
       executionPhase = 'EXEC_BRIEF_DRAFT';
     }
 
-=======
->>>>>>> 1e46cab (chore: lock executive brief render + pdf contracts)
     // Get tenant info with owner
     const [tenantData] = await db
       .select({
@@ -773,11 +699,7 @@ export async function getFirmDetail(req: AuthRequest<{ tenantId: string }>, res:
         ownerRole: users.role,
       })
       .from(tenants)
-<<<<<<< HEAD
       .leftJoin(users, eq(tenants.ownerUserId, users.id))
-=======
-      .innerJoin(users, eq(tenants.ownerUserId, users.id))
->>>>>>> 1e46cab (chore: lock executive brief render + pdf contracts)
       .where(eq(tenants.id, tenantId))
       .limit(1);
 
@@ -822,7 +744,6 @@ export async function getFirmDetail(req: AuthRequest<{ tenantId: string }>, res:
 
     // Get roadmaps for this firm
     const firmRoadmaps = await db
-<<<<<<< HEAD
       .select({
         id: roadmaps.id,
         status: roadmaps.status,
@@ -830,9 +751,6 @@ export async function getFirmDetail(req: AuthRequest<{ tenantId: string }>, res:
         createdAt: roadmaps.createdAt,
         updatedAt: roadmaps.updatedAt
       })
-=======
-      .select()
->>>>>>> 1e46cab (chore: lock executive brief render + pdf contracts)
       .from(roadmaps)
       .where(eq(roadmaps.tenantId, tenantId))
       .orderBy(desc(roadmaps.createdAt));
@@ -864,13 +782,8 @@ export async function getFirmDetail(req: AuthRequest<{ tenantId: string }>, res:
     // Roadmap stats
     const roadmapStats = {
       total: firmRoadmaps.length,
-<<<<<<< HEAD
       delivered: firmRoadmaps.filter((r) => r.status === 'published').length,
       draft: firmRoadmaps.filter((r) => r.status === 'draft').length,
-=======
-      delivered: firmRoadmaps.filter((r) => r.status === 'delivered').length,
-      draft: firmRoadmaps.filter((r) => r.status !== 'delivered').length,
->>>>>>> 1e46cab (chore: lock executive brief render + pdf contracts)
     };
 
     // Documents summary by category
@@ -914,7 +827,6 @@ export async function getFirmDetail(req: AuthRequest<{ tenantId: string }>, res:
       diagnosticStatus = await getModerationStatus(tenantId, tenantData.lastDiagnosticId);
     }
 
-<<<<<<< HEAD
     // CANONICAL DIAGNOSTIC STATE: Query diagnostics table
     const [latestDiagnostic] = await db
       .select({
@@ -940,8 +852,6 @@ export async function getFirmDetail(req: AuthRequest<{ tenantId: string }>, res:
 
     const discoveryComplete = !!discoveryDoc;
 
-=======
->>>>>>> 1e46cab (chore: lock executive brief render + pdf contracts)
     return res.json({
       tenantSummary: {
         id: tenantData.tenantId,
@@ -950,11 +860,8 @@ export async function getFirmDetail(req: AuthRequest<{ tenantId: string }>, res:
         segment: tenantData.segment,
         region: tenantData.region,
         status: tenantData.status,
-<<<<<<< HEAD
         executiveBriefStatus: briefStatus,
         executionPhase,
-=======
->>>>>>> 1e46cab (chore: lock executive brief render + pdf contracts)
         businessType: tenantData.businessType,
         teamHeadcount: tenantData.teamHeadcount,
         baselineMonthlyLeads: tenantData.baselineMonthlyLeads,
@@ -966,13 +873,10 @@ export async function getFirmDetail(req: AuthRequest<{ tenantId: string }>, res:
         intakeSnapshotId: tenantData.intakeSnapshotId,
       },
       diagnosticStatus, // Added for Ticket 5 gating
-<<<<<<< HEAD
       latestDiagnostic: latestDiagnostic || null, // CANONICAL: diagnostics table source of truth
       discoveryStatus: {
         complete: discoveryComplete
       },
-=======
->>>>>>> 1e46cab (chore: lock executive brief render + pdf contracts)
       owner: owner ? {
         id: owner.id,
         name: owner.name,
@@ -1160,7 +1064,6 @@ export async function getFirmDetailV2(req: AuthRequest<{ tenantId: string }>, re
 
     // 7. ROADMAPS
     const roadmapsData = await db
-<<<<<<< HEAD
       .select({
         id: roadmaps.id,
         status: roadmaps.status,
@@ -1169,9 +1072,6 @@ export async function getFirmDetailV2(req: AuthRequest<{ tenantId: string }>, re
         updatedAt: roadmaps.updatedAt,
         modelJson: roadmaps.modelJson
       })
-=======
-      .select()
->>>>>>> 1e46cab (chore: lock executive brief render + pdf contracts)
       .from(roadmaps)
       .where(eq(roadmaps.tenantId, tenantId))
       .orderBy(desc(roadmaps.createdAt));
@@ -1309,11 +1209,7 @@ export async function getFirmDetailV2(req: AuthRequest<{ tenantId: string }>, re
       engagementSummary: {
         last30d: {
           intakeCompleted: Number(metricsLast30d[0]?.intakeCompleted || 0),
-<<<<<<< HEAD
           roadmapsPublished: Number(metricsLast30d[0]?.roadmapsDelivered || 0),
-=======
-          roadmapsDelivered: Number(metricsLast30d[0]?.roadmapsDelivered || 0),
->>>>>>> 1e46cab (chore: lock executive brief render + pdf contracts)
         },
         lifetime: {
           intakeCompleted: Number(metricsLifetime[0]?.intakeCompleted || 0),
@@ -1337,11 +1233,7 @@ export async function getFirmDetailV2(req: AuthRequest<{ tenantId: string }>, re
           ? {
             id: lastRoadmap.id,
             status: lastRoadmap.status,
-<<<<<<< HEAD
             deliveredAt: lastRoadmap.status === 'delivered' ? lastRoadmap.updatedAt : null,
-=======
-            deliveredAt: lastRoadmap.deliveredAt,
->>>>>>> 1e46cab (chore: lock executive brief render + pdf contracts)
             createdAt: lastRoadmap.createdAt,
           }
           : null,
@@ -2703,7 +2595,6 @@ export async function signalReadiness(req: AuthRequest, res: Response) {
 
 
 
-<<<<<<< HEAD
 
 // ============================================================================
 // TRUTH PROBE (Lifecycle State)
@@ -3101,10 +2992,15 @@ export async function generateDiagnostics(req: AuthRequest, res: Response) {
       tenantId,
       sopVersion: 'SOP-01',
       status: 'generated' as const,
-      overview: { markdown: outputs.companyDiagnosticMap },
-      aiOpportunities: { markdown: outputs.aiLeverageMap },
-      roadmapSkeleton: { markdown: outputs.roadmapSkeleton },
-      discoveryQuestions: { list: outputs.discoveryCallQuestions },
+      overview: { markdown: outputs.sop01DiagnosticMarkdown },
+      aiOpportunities: { markdown: outputs.sop01AiLeverageMarkdown },
+      roadmapSkeleton: { markdown: outputs.sop01RoadmapSkeletonMarkdown },
+      discoveryQuestions: {
+        list: outputs.sop01DiscoveryQuestionsMarkdown
+          .split('\n')
+          .map(q => q.trim())
+          .filter(Boolean)
+      },
       generatedByUserId: req.user!.id || null,
       updatedAt: new Date()
     };
@@ -4059,2491 +3955,3 @@ export async function resetAgentSession(req: AuthRequest, res: Response) {
     });
   }
 }
-=======
-import { Response } from 'express';
-import { nanoid } from 'nanoid';
-import { db } from '../db';
-import { users, intakes, tenants, roadmaps, auditEvents, tenantDocuments, discoveryCallNotes, roadmapSections, ticketPacks, ticketInstances, tenantMetricsDaily, webinarRegistrations, implementationSnapshots, roadmapOutcomes, agentConfigs, agentThreads, webinarSettings, diagnostics, executiveBriefs } from '../db/schema';
-import { eq, and, sql, count, desc, asc } from 'drizzle-orm';
-import { AuthRequest } from '../middleware/auth';
-import path from 'path';
-import fs from 'fs/promises';
-import { generateTicketPackForRoadmap } from '../services/ticketPackGenerator.service';
-import { extractRoadmapMetadata } from '../services/roadmapMetadataExtractor.service';
-import { ImplementationMetricsService } from '../services/implementationMetrics.service';
-import { getOrCreateRoadmapForTenant } from '../services/roadmapOs.service';
-import { refreshVectorStoreContent } from '../services/tenantVectorStore.service';
-import { getModerationStatus } from '../services/ticketModeration.service';
-import { AUDIT_EVENT_TYPES } from '../constants/auditEventTypes';
-import { AuthorityCategory } from '@roadmap/shared';
-const UPLOADS_DIR = path.join(__dirname, '../../uploads');
-
-// ============================================================================
-// HELPER: Check SuperAdmin Permission
-// ============================================================================
-
-/**
- * Helper to ensure the user is part of the Consulting Team (SuperAdmin or Delegate)
- */
-function requireConsultant(req: AuthRequest, res: Response): boolean {
-  const allowedRoles = ['superadmin', 'delegate', 'exec_sponsor'];
-  if (!req.user || !req.user.isInternal || !allowedRoles.includes(req.user.role as string)) {
-    res.status(403).json({ error: 'Consulting Team access required' });
-    return false;
-  }
-  return true;
-}
-
-function requireSuperAdmin(req: AuthRequest, res: Response): boolean {
-  if (!req.user || (req.user.role as string) !== 'superadmin') {
-    res.status(403).json({ error: 'SuperAdmin access required' });
-    return false;
-  }
-  return true;
-}
-
-/**
- * Authority check for Executive-only surfaces.
- * Maps roles to the Executive category.
- */
-function requireExecutiveAuthority(req: AuthRequest, res: Response): boolean {
-  const executiveRoles = ['superadmin', 'exec_sponsor', 'owner'];
-  if (!req.user || !executiveRoles.includes(req.user.role as string)) {
-    // Structural Gating: Return 404/Null to prevent inference of existence
-    res.status(404).json({ error: 'Not Found' });
-    return false;
-  }
-  return true;
-}
-
-// ============================================================================
-// GET /api/superadmin/overview - Global Dashboard Stats
-// ============================================================================
-
-export async function getOverview(req: AuthRequest<any, any, any, { cohortLabel?: string }>, res: Response) {
-  try {
-    if (!requireSuperAdmin(req, res)) return;
-
-    // Count total tenants
-    const [{ totalFirms }] = await db
-      .select({ totalFirms: count() })
-      .from(tenants);
-
-    // Count intake completions
-    const [{ totalIntakes }] = await db
-      .select({ totalIntakes: count() })
-      .from(intakes);
-
-    // Count tenants by status
-    const statusStats = await db
-      .select({
-        status: tenants.status,
-        count: count(),
-      })
-      .from(tenants)
-      .groupBy(tenants.status);
-
-    // Count roadmaps by status
-    const roadmapStats = await db
-      .select({
-        status: roadmaps.status,
-        count: count(),
-      })
-      .from(roadmaps)
-      .groupBy(roadmaps.status);
-
-    // Count roadmaps by pilot stage (exclude nulls)
-    const pilotStats = await db
-      .select({
-        pilotStage: roadmaps.pilotStage,
-        count: count(),
-      })
-      .from(roadmaps)
-      .where(sql`${roadmaps.pilotStage} IS NOT NULL`)
-      .groupBy(roadmaps.pilotStage);
-
-    // Count by cohort
-    const cohortStats = await db
-      .select({
-        cohortLabel: tenants.cohortLabel,
-        count: count(),
-      })
-      .from(tenants)
-      .where(sql`${tenants.cohortLabel} IS NOT NULL`)
-      .groupBy(tenants.cohortLabel);
-
-    return res.json({
-      totalFirms: totalFirms || 0,
-      totalIntakes: totalIntakes || 0,
-      statusStats,
-      roadmapStats,
-      pilotStats,
-      cohortStats,
-    });
-  } catch (error) {
-    console.error('Get overview error:', error);
-    return res.status(500).json({ error: 'Failed to fetch overview' });
-  }
-}
-
-// ============================================================================
-// GET ACTIVITY FEED
-// ============================================================================
-
-export async function getActivityFeed(req: AuthRequest<any, any, any, { limit?: string }>, res: Response) {
-  try {
-    if (!requireSuperAdmin(req, res)) return;
-
-    const limit = parseInt(req.query.limit || '50', 10);
-
-    // Fetch recent audit events with actor and tenant information
-    const events = await db
-      .select({
-        id: auditEvents.id,
-        eventType: auditEvents.eventType,
-        entityType: auditEvents.entityType,
-        metadata: auditEvents.metadata,
-        createdAt: auditEvents.createdAt,
-        actorName: users.name,
-        actorRole: auditEvents.actorRole,
-        tenantId: tenants.id,
-        tenantName: tenants.name,
-      })
-      .from(auditEvents)
-      .leftJoin(users, eq(auditEvents.actorUserId, users.id))
-      .leftJoin(tenants, eq(auditEvents.tenantId, tenants.id))
-      .orderBy(desc(auditEvents.createdAt))
-      .limit(limit);
-
-    // Transform events into activity feed format
-    const activities = events.map((event) => {
-      const actor = event.actorName || 'System';
-      const action = formatEventAction(event.eventType, event.metadata);
-      const target = event.tenantName || 'System';
-
-      return {
-        id: event.id,
-        actor,
-        action,
-        target,
-        tenantId: event.tenantId,
-        timestamp: event.createdAt,
-        type: event.entityType || 'system',
-      };
-    });
-
-    return res.json({ activities });
-  } catch (error) {
-    console.error('Get activity feed error:', error);
-    return res.status(500).json({ error: 'Failed to fetch activity feed' });
-  }
-}
-
-// Helper function to format event types into readable actions
-function formatEventAction(eventType: string, metadata: any): string {
-  const metadataObj = metadata as Record<string, any> || {};
-
-  switch (eventType) {
-    case 'intake_completed':
-      return 'completed Intake';
-    case 'intake_reopened':
-      return 'reopened Intake';
-    case 'diagnostic_generated':
-      return 'generated SOP-01 Diagnostic';
-    case 'roadmap_created':
-      return 'created Roadmap';
-    case 'roadmap_status_changed':
-      return `updated Roadmap to ${metadataObj.newStatus || 'new status'}`;
-    case 'discovery_acknowledged':
-      return 'acknowledged Discovery';
-    case 'intake_window_closed':
-      return 'closed Intake Window';
-    case 'intake_window_reopened':
-      return 'reopened Intake Window';
-    case 'exec_ready_approved':
-      return 'approved for Execution';
-    case 'ticket_pack_generated':
-      return 'generated Ticket Pack';
-    default:
-      return eventType.replace(/_/g, ' ');
-  }
-}
-
-
-export async function updateIntakeCoaching(req: AuthRequest<{ intakeId: string }, any, { coachingFeedback: any }>, res: Response) {
-  try {
-    if (!requireConsultant(req, res)) return;
-
-    const { intakeId } = req.params;
-    const { coachingFeedback } = req.body;
-
-    const [intake] = await db
-      .select({
-        id: intakes.id,
-        tenantId: intakes.tenantId,
-      })
-      .from(intakes)
-      .where(eq(intakes.id, intakeId))
-      .limit(1);
-
-    if (!intake) {
-      return res.status(404).json({ error: 'Intake not found' });
-    }
-
-    await db
-      .update(intakes)
-      .set({
-        coachingFeedback,
-      })
-      .where(eq(intakes.id, intakeId));
-
-    return res.json({ ok: true });
-  } catch (error) {
-    console.error('Update intake coaching error:', error);
-    return res.status(500).json({ error: 'Failed to update coaching feedback' });
-  }
-}
-
-export async function reopenIntake(req: AuthRequest<{ intakeId: string }>, res: Response) {
-  try {
-    if (!requireConsultant(req, res)) return;
-    if (!requireExecutiveAuthority(req, res)) return;
-
-    const { intakeId } = req.params;
-
-    const [intake] = await db
-      .select({
-        id: intakes.id,
-        tenantId: intakes.tenantId,
-      })
-      .from(intakes)
-      .where(eq(intakes.id, intakeId))
-      .limit(1);
-
-    if (!intake) {
-      return res.status(404).json({ error: 'Intake not found' });
-    }
-
-    // GATING: Block reopen if Intake Window is CLOSED (drift prevention)
-    const [tenant] = await db
-      .select({ intakeWindowState: tenants.intakeWindowState })
-      .from(tenants)
-      .where(eq(tenants.id, intake.tenantId))
-      .limit(1);
-
-    if (tenant && tenant.intakeWindowState === 'CLOSED') {
-      return res.status(403).json({
-        error: 'Gated Action',
-        details: 'Cannot reopen an intake after the Intake Window is CLOSED. Reopen the window via a new cycle (not supported in this mode).'
-      });
-    }
-
-    await db
-      .update(intakes)
-      .set({
-        status: 'in_progress',
-        completedAt: null,
-      })
-      .where(eq(intakes.id, intakeId));
-
-    // Audit Log
-    await db.insert(auditEvents).values({
-      tenantId: intake.tenantId,
-      actorUserId: req.user?.userId,
-      actorRole: req.user?.role as string,
-      eventType: 'INTAKE_REOPENED',
-      entityType: 'intake',
-      entityId: intakeId,
-      metadata: { reopenedAt: new Date() },
-    });
-
-    return res.json({ ok: true });
-  } catch (error) {
-    console.error('Re-open intake error:', error);
-    return res.status(500).json({ error: 'Failed to re-open intake' });
-  }
-}
-
-
-// ============================================================================
-// GET /api/superadmin/tenants - Simple List for Dropdowns
-// ============================================================================
-
-export async function getTenants(req: AuthRequest<any, any, any, { search?: string }>, res: Response) {
-  try {
-    if (!requireSuperAdmin(req, res)) return;
-
-    const tenantList = await db
-      .select({
-        id: tenants.id,
-        name: tenants.name,
-      })
-      .from(tenants)
-      .orderBy(asc(tenants.name));
-
-    return res.json({ tenants: tenantList });
-  } catch (error) {
-    console.error('Get tenants error:', error);
-    return res.status(500).json({ error: 'Failed to fetch tenants' });
-  }
-}
-
-// ============================================================================
-// GET /api/superadmin/roadmaps - List All Client Roadmaps
-// ============================================================================
-
-export async function getAllRoadmaps(req: AuthRequest<any, any, any, { cohort?: string; status?: string; search?: string }>, res: Response) {
-  try {
-    if (!requireSuperAdmin(req, res)) return;
-
-    const { cohort, status, search } = req.query as {
-      cohort?: string;
-      status?: string;
-      search?: string;
-    };
-
-    // Build where conditions
-    const whereConditions = [];
-    if (cohort) whereConditions.push(eq(tenants.cohortLabel, cohort));
-    if (status) whereConditions.push(eq(roadmaps.status, status));
-    if (search) whereConditions.push(sql`${tenants.name} ILIKE ${'%' + search + '%'}`);
-
-    const rows = await db
-      .select({
-        id: roadmaps.id,
-        tenantId: tenants.id,
-        tenantName: tenants.name,
-        cohortLabel: tenants.cohortLabel,
-        segment: tenants.segment,
-        region: tenants.region,
-        status: roadmaps.status,
-        pilotStage: roadmaps.pilotStage,
-        createdAt: roadmaps.createdAt,
-        deliveredAt: roadmaps.deliveredAt,
-        pdfUrl: roadmaps.pdfUrl,
-      })
-      .from(roadmaps)
-      .innerJoin(tenants, eq(roadmaps.tenantId, tenants.id))
-      .where(whereConditions.length > 0 ? and(...whereConditions) : undefined)
-      .orderBy(desc(roadmaps.createdAt));
-
-    return res.json({ roadmaps: rows });
-  } catch (error) {
-    console.error('Get all roadmaps error:', error);
-    return res.status(500).json({ error: 'Failed to fetch roadmaps' });
-  }
-}
-
-// ============================================================================
-// GET /api/superadmin/firms - List All Firms with Lifecycle Data
-// ============================================================================
-
-export async function getFirms(req: AuthRequest<any, any, any, { cohortLabel?: string }>, res: Response) {
-  try {
-    if (!requireSuperAdmin(req, res)) return;
-
-    const cohortFilter = req.query.cohortLabel as string | undefined;
-
-    // Base query for all tenants with owner info
-    let query = db
-      .select({
-        tenantId: tenants.id,
-        tenantName: tenants.name,
-        cohortLabel: tenants.cohortLabel,
-        segment: tenants.segment,
-        region: tenants.region,
-        status: tenants.status,
-        notes: tenants.notes,
-        tenantCreatedAt: tenants.createdAt,
-        ownerUserId: users.id,
-        ownerName: users.name,
-        ownerEmail: users.email,
-      })
-      .from(tenants)
-      .innerJoin(users, eq(tenants.ownerUserId, users.id));
-
-    // Apply cohort filter if provided
-    const allTenants = cohortFilter
-      ? await query.where(eq(tenants.cohortLabel, cohortFilter))
-      : await query;
-
-    // For each tenant, get intake count
-    const firmsWithStats = await Promise.all(
-      allTenants.map(async (tenant) => {
-        const [{ intakeCount }] = await db
-          .select({ intakeCount: count() })
-          .from(intakes)
-          .where(eq(intakes.tenantId, tenant.tenantId));
-
-        const [{ roadmapCount }] = await db
-          .select({ roadmapCount: count() })
-          .from(roadmaps)
-          .where(eq(roadmaps.tenantId, tenant.tenantId));
-
-        return {
-          tenantId: tenant.tenantId,
-          name: tenant.tenantName,
-          ownerEmail: tenant.ownerEmail,
-          cohortLabel: tenant.cohortLabel,
-          segment: tenant.segment,
-          region: tenant.region,
-          status: tenant.status,
-          intakeCount: intakeCount || 0,
-          roadmapCount: roadmapCount || 0,
-          createdAt: tenant.tenantCreatedAt,
-        };
-      })
-    );
-
-    return res.json({ firms: firmsWithStats });
-  } catch (error) {
-    console.error('Get firms error:', error);
-    return res.status(500).json({ error: 'Failed to fetch firms' });
-  }
-}
-
-// ============================================================================
-// GET /api/superadmin/firms/:tenantId/client-context - Get Client Preview Context
-// ============================================================================
-
-export async function getClientContextForFirm(req: AuthRequest, res: Response) {
-  try {
-    if (!requireSuperAdmin(req, res)) return;
-
-    const { tenantId } = req.params;
-
-    const [tenant] = await db
-      .select()
-      .from(tenants)
-      .where(eq(tenants.id, tenantId))
-      .limit(1);
-
-    if (!tenant) {
-      return res.status(404).json({ error: 'Tenant not found' });
-    }
-
-    const [owner] = await db
-      .select()
-      .from(users)
-      .where(eq(users.id, tenant.ownerUserId))
-      .limit(1);
-
-    return res.json({
-      tenantId: tenant.id,
-      tenantName: tenant.name,
-      cohortLabel: tenant.cohortLabel,
-      segment: tenant.segment,
-      region: tenant.region,
-      ownerName: owner?.name || 'Owner',
-      ownerEmail: owner?.email || '',
-      ownerUserId: owner?.id,
-    });
-  } catch (error) {
-    console.error('Get client context error:', error);
-    return res.status(500).json({ error: 'Failed to fetch client context' });
-  }
-}
-
-// ============================================================================
-// GET /api/superadmin/firms/:tenantId/roadmap-sections - Get Roadmap Sections
-// ============================================================================
-
-export async function getRoadmapSectionsForFirm(req: AuthRequest, res: Response) {
-  try {
-    if (!requireSuperAdmin(req, res)) return;
-
-    const { tenantId } = req.params;
-
-    const [tenant] = await db
-      .select({
-        id: tenants.id,
-        name: tenants.name,
-        cohortLabel: tenants.cohortLabel,
-      })
-      .from(tenants)
-      .where(eq(tenants.id, tenantId))
-      .limit(1);
-
-    if (!tenant) {
-      return res.status(404).json({ error: 'Tenant not found' });
-    }
-
-    const docs = await db
-      .select()
-      .from(tenantDocuments)
-      .where(
-        and(
-          eq(tenantDocuments.tenantId, tenantId),
-          eq(tenantDocuments.category, 'roadmap')
-        )
-      )
-      .orderBy(asc(tenantDocuments.section));
-
-    return res.json({
-      tenant: {
-        id: tenant.id,
-        name: tenant.name,
-        cohortLabel: tenant.cohortLabel,
-      },
-      sections: docs.map((d) => ({
-        id: d.id,
-        title: d.title,
-        section: d.section,
-        description: d.description,
-        createdAt: d.createdAt,
-      })),
-    });
-  } catch (error) {
-    console.error('Get roadmap sections error:', error);
-    return res.status(500).json({ error: 'Failed to fetch roadmap sections' });
-  }
-}
-
-// ============================================================================
-// POST /api/superadmin/firms/:tenantId/close-intake
-// ============================================================================
-
-export async function closeIntakeWindow(req: AuthRequest<{ tenantId: string }>, res: Response) {
-  try {
-    if (!requireSuperAdmin(req, res)) return;
-    if (!requireExecutiveAuthority(req, res)) return;
-
-    const { tenantId } = req.params;
-
-    // GATING: Block close unless Executive Brief is ACKNOWLEDGED or WAIVED
-    const [brief] = await db
-      .select()
-      .from(executiveBriefs)
-      .where(eq(executiveBriefs.tenantId, tenantId))
-      .limit(1);
-
-    if (!brief || !(['ACKNOWLEDGED', 'WAIVED'].includes(brief.status))) {
-      return res.status(403).json({
-        error: 'Gated Action',
-        details: 'Executive Brief must be ACKNOWLEDGED or WAIVED before closing the Intake Window.'
-      });
-    }
-
-    // Deterministic Snapshot ID
-    const snapshotId = `intake_snap_${nanoid()}`;
-    const closedAt = new Date();
-
-    // 1. Freeze the Tenant State
-    await db
-      .update(tenants)
-      .set({
-        intakeWindowState: 'CLOSED',
-        intakeSnapshotId: snapshotId,
-        intakeClosedAt: closedAt,
-      })
-      .where(eq(tenants.id, tenantId));
-
-    // 2. Audit Log (Critical for Authority Contract)
-    await db.insert(auditEvents).values({
-      tenantId,
-      actorUserId: req.user?.userId,
-      actorRole: req.user?.role as string,
-      eventType: 'intake_window_closed',
-      entityType: 'tenant',
-      entityId: tenantId,
-      metadata: { snapshotId, closedAt },
-    });
-
-    return res.json({ ok: true, snapshotId, closedAt: closedAt.toISOString() });
-
-  } catch (error) {
-    console.error('Close intake window error:', error);
-    return res.status(500).json({ error: 'Failed to close intake window' });
-  }
-}
-
-// ============================================================================
-// GET /api/superadmin/firms/:tenantId - Firm Detail
-// ============================================================================
-
-export async function getFirmDetail(req: AuthRequest<{ tenantId: string }>, res: Response) {
-  try {
-    if (!requireSuperAdmin(req, res)) return;
-
-    const { tenantId } = req.params;
-
-    // Get tenant info with owner
-    const [tenantData] = await db
-      .select({
-        tenantId: tenants.id,
-        tenantName: tenants.name,
-        cohortLabel: tenants.cohortLabel,
-        segment: tenants.segment,
-        region: tenants.region,
-        status: tenants.status,
-        businessType: tenants.businessType,
-        teamHeadcount: tenants.teamHeadcount,
-        baselineMonthlyLeads: tenants.baselineMonthlyLeads,
-        firmSizeTier: tenants.firmSizeTier,
-        notes: tenants.notes,
-        lastDiagnosticId: tenants.lastDiagnosticId,
-        intakeWindowState: tenants.intakeWindowState,
-        intakeSnapshotId: tenants.intakeSnapshotId,
-        intakeClosedAt: tenants.intakeClosedAt,
-        tenantCreatedAt: tenants.createdAt,
-        ownerUserId: users.id,
-        ownerName: users.name,
-        ownerEmail: users.email,
-        ownerRole: users.role,
-      })
-      .from(tenants)
-      .innerJoin(users, eq(tenants.ownerUserId, users.id))
-      .where(eq(tenants.id, tenantId))
-      .limit(1);
-
-    if (!tenantData) {
-      return res.status(404).json({ error: 'Firm not found' });
-    }
-
-    // Get team members (all users in this tenant)
-    const teamMembers = await db
-      .select({
-        id: users.id,
-        name: users.name,
-        email: users.email,
-        role: users.role,
-        createdAt: users.createdAt,
-      })
-      .from(users)
-      .where(eq(users.tenantId, tenantId));
-
-    // Separate owner from team
-    const owner = teamMembers.find(u => u.id === tenantData.ownerUserId);
-    const team = teamMembers.filter(u => u.id !== tenantData.ownerUserId);
-
-    // Get intakes for this firm
-    const firmIntakes = await db
-      .select()
-      .from(intakes)
-      .innerJoin(users, eq(intakes.userId, users.id))
-      .where(eq(intakes.tenantId, tenantId));
-
-    const formattedIntakes = firmIntakes.map(row => ({
-      id: row.intakes.id,
-      role: row.intakes.role,
-      status: row.intakes.status,
-      answers: row.intakes.answers,
-      coachingFeedback: row.intakes.coachingFeedback,
-      createdAt: row.intakes.createdAt,
-      completedAt: row.intakes.completedAt,
-      userName: row.users.name,
-      userEmail: row.users.email,
-    }));
-
-    // Get roadmaps for this firm
-    const firmRoadmaps = await db
-      .select()
-      .from(roadmaps)
-      .where(eq(roadmaps.tenantId, tenantId))
-      .orderBy(desc(roadmaps.createdAt));
-
-    const latestRoadmap = firmRoadmaps[0] || null;
-
-
-
-    // Get aggregate metrics (last 30 days)
-    const metricsRows = await db
-      .select({
-        intakeStarted: sql<number>`COALESCE(SUM(${tenantMetricsDaily.intakeStartedCount}), 0)`,
-        intakeCompleted: sql<number>`COALESCE(SUM(${tenantMetricsDaily.intakeCompletedCount}), 0)`,
-        roadmapCreated: sql<number>`COALESCE(SUM(${tenantMetricsDaily.roadmapCreatedCount}), 0)`,
-        roadmapDelivered: sql<number>`COALESCE(SUM(${tenantMetricsDaily.roadmapDeliveredCount}), 0)`,
-        lastActivityAt: sql<Date | null>`MAX(${tenantMetricsDaily.lastActivityAt})`,
-      })
-      .from(tenantMetricsDaily)
-      .where(eq(tenantMetricsDaily.tenantId, tenantId));
-
-    const aggregateMetrics = metricsRows[0] || {
-      intakeStarted: 0,
-      intakeCompleted: 0,
-      roadmapCreated: 0,
-      roadmapDelivered: 0,
-      lastActivityAt: null,
-    };
-
-    // Roadmap stats
-    const roadmapStats = {
-      total: firmRoadmaps.length,
-      delivered: firmRoadmaps.filter((r) => r.status === 'delivered').length,
-      draft: firmRoadmaps.filter((r) => r.status !== 'delivered').length,
-    };
-
-    // Documents summary by category
-    const docs = await db
-      .select({
-        category: tenantDocuments.category,
-        count: sql<number>`COUNT(*)`,
-      })
-      .from(tenantDocuments)
-      .where(eq(tenantDocuments.tenantId, tenantId))
-      .groupBy(tenantDocuments.category);
-
-    const documentSummary: Record<string, number> = {};
-    for (const row of docs) {
-      documentSummary[row.category] = Number(row.count);
-    }
-
-    // Get recent audit events
-    const recentAudits = await db
-      .select()
-      .from(auditEvents)
-      .leftJoin(users, eq(auditEvents.actorUserId, users.id))
-      .where(eq(auditEvents.tenantId, tenantId))
-      .orderBy(desc(auditEvents.createdAt))
-      .limit(20);
-
-    const formattedAudits = recentAudits.map(row => ({
-      id: row.audit_events.id,
-      eventType: row.audit_events.eventType,
-      entityType: row.audit_events.entityType,
-      entityId: row.audit_events.entityId,
-      metadata: row.audit_events.metadata,
-      createdAt: row.audit_events.createdAt,
-      actorName: row.users?.name || 'System',
-      actorRole: row.audit_events.actorRole,
-    }));
-
-    // GATING: Fetch diagnostic status (for Roadmap readiness)
-    let diagnosticStatus = { total: 0, pending: 0, approved: 0, rejected: 0, readyForRoadmap: false };
-    if (tenantData.lastDiagnosticId) {
-      diagnosticStatus = await getModerationStatus(tenantId, tenantData.lastDiagnosticId);
-    }
-
-    return res.json({
-      tenantSummary: {
-        id: tenantData.tenantId,
-        name: tenantData.tenantName,
-        cohortLabel: tenantData.cohortLabel,
-        segment: tenantData.segment,
-        region: tenantData.region,
-        status: tenantData.status,
-        businessType: tenantData.businessType,
-        teamHeadcount: tenantData.teamHeadcount,
-        baselineMonthlyLeads: tenantData.baselineMonthlyLeads,
-        firmSizeTier: tenantData.firmSizeTier,
-        createdAt: tenantData.tenantCreatedAt,
-        notes: tenantData.notes,
-        lastDiagnosticId: tenantData.lastDiagnosticId,
-        intakeWindowState: tenantData.intakeWindowState,
-        intakeSnapshotId: tenantData.intakeSnapshotId,
-      },
-      diagnosticStatus, // Added for Ticket 5 gating
-      owner: owner ? {
-        id: owner.id,
-        name: owner.name,
-        email: owner.email,
-        role: owner.role,
-        createdAt: owner.createdAt,
-      } : null,
-      teamMembers: team,
-
-      activitySummary: {
-        intakeStarted: Number(aggregateMetrics.intakeStarted) || 0,
-        intakeCompleted: Number(aggregateMetrics.intakeCompleted) || 0,
-        roadmapCreated: Number(aggregateMetrics.roadmapCreated) || 0,
-        roadmapDelivered: Number(aggregateMetrics.roadmapDelivered) || 0,
-        lastActivityAt: aggregateMetrics.lastActivityAt,
-      },
-      roadmapStats,
-      documentSummary,
-      intakes: formattedIntakes,
-      roadmaps: firmRoadmaps,
-      latestRoadmap, // Canonical source of truth
-      recentActivity: formattedAudits,
-    });
-  } catch (error) {
-    console.error('Get firm detail error:', error);
-    return res.status(500).json({ error: 'Failed to fetch firm detail' });
-  }
-}
-
-// ============================================================================
-// GET /api/superadmin/firms/:tenantId/detail - Firm Detail V2 (Single Source of Truth)
-// ============================================================================
-
-export async function getFirmDetailV2(req: AuthRequest<{ tenantId: string }>, res: Response) {
-  try {
-    if (!requireSuperAdmin(req, res)) return;
-
-    const { tenantId } = req.params;
-
-    // -----------------------------------------------------------------------
-    // 1. Tenant + Owner
-    // -----------------------------------------------------------------------
-    const [tenantRow] = await db
-      .select({
-        tenantId: tenants.id,
-        tenantName: tenants.name,
-        cohortLabel: tenants.cohortLabel,
-        segment: tenants.segment,
-        region: tenants.region,
-        status: tenants.status,
-        businessType: tenants.businessType,
-        teamHeadcount: tenants.teamHeadcount,
-        baselineMonthlyLeads: tenants.baselineMonthlyLeads,
-        firmSizeTier: tenants.firmSizeTier,
-        notes: tenants.notes,
-        lastDiagnosticId: tenants.lastDiagnosticId,
-        discoveryComplete: tenants.discoveryComplete,
-        discoveryAcknowledgedAt: tenants.discoveryAcknowledgedAt,
-        tenantCreatedAt: tenants.createdAt,
-        tenantUpdatedAt: tenants.updatedAt,
-        ownerUserId: tenants.ownerUserId,
-        intakeWindowState: tenants.intakeWindowState,
-      })
-      .from(tenants)
-      .where(eq(tenants.id, tenantId))
-      .limit(1);
-
-    if (!tenantRow) {
-      return res.status(404).json({ error: 'Firm not found' });
-    }
-
-    // 1.1 Fetch Executive Brief Status & Derive Phase
-    const [execBrief] = await db
-      .select({ status: executiveBriefs.status })
-      .from(executiveBriefs)
-      .where(eq(executiveBriefs.tenantId, tenantId))
-      .limit(1);
-
-    const briefStatus = execBrief?.status || null;
-
-    let executionPhase = 'INTAKE_OPEN';
-    if (briefStatus === 'APPROVED') {
-      executionPhase = 'EXEC_BRIEF_APPROVED';
-    } else if (briefStatus === 'DRAFT') {
-      executionPhase = 'EXEC_BRIEF_DRAFT';
-    } else if (tenantRow.intakeWindowState === 'OPEN') {
-      executionPhase = 'INTAKE_OPEN';
-    } else if (tenantRow.intakeWindowState === 'CLOSED') {
-      // Fallback if closed but no brief (e.g. manual close or legacy)
-      executionPhase = 'INTAKE_CLOSED';
-    }
-
-    const [owner] = await db
-      .select({
-        id: users.id,
-        name: users.name,
-        email: users.email,
-        role: users.role,
-        createdAt: users.createdAt,
-      })
-      .from(users)
-      .where(eq(users.id, tenantRow.ownerUserId))
-      .limit(1);
-
-
-
-    // 3. ENGAGEMENT SUMMARY (last 30 days + lifetime)
-    const thirtyDaysAgo = new Date();
-    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
-
-    const metricsLast30d = await db
-      .select({
-        intakeCompleted: sql<number>`COALESCE(SUM(${tenantMetricsDaily.intakeCompletedCount}), 0)`,
-        roadmapsDelivered: sql<number>`COALESCE(SUM(${tenantMetricsDaily.roadmapDeliveredCount}), 0)`,
-      })
-      .from(tenantMetricsDaily)
-      .where(
-        and(
-          eq(tenantMetricsDaily.tenantId, tenantId),
-          sql`${tenantMetricsDaily.metricDate} >= ${thirtyDaysAgo.toISOString().split('T')[0]}`
-        )
-      );
-
-    const metricsLifetime = await db
-      .select({
-        intakeCompleted: sql<number>`COALESCE(SUM(${tenantMetricsDaily.intakeCompletedCount}), 0)`,
-        roadmapsDelivered: sql<number>`COALESCE(SUM(${tenantMetricsDaily.roadmapDeliveredCount}), 0)`,
-      })
-      .from(tenantMetricsDaily)
-      .where(eq(tenantMetricsDaily.tenantId, tenantId));
-
-    // 4. INTAKES (by role)
-    const intakesData = await db
-      .select({
-        role: intakes.role,
-        status: intakes.status,
-        completedAt: intakes.completedAt,
-      })
-      .from(intakes)
-      .where(eq(intakes.tenantId, tenantId));
-
-    const intakesByRole: Record<string, { status: string; completedAt: Date | null } | null> = {
-      owner: null,
-      sales: null,
-      ops: null,
-      delivery: null,
-    };
-
-    intakesData.forEach((intake) => {
-      if (['owner', 'sales', 'ops', 'delivery'].includes(intake.role)) {
-        intakesByRole[intake.role] = {
-          status: intake.status || 'not_started',
-          completedAt: intake.completedAt,
-        };
-      }
-    });
-
-    // 5. DISCOVERY
-    const [discoveryNote] = await db
-      .select()
-      .from(discoveryCallNotes)
-      .where(eq(discoveryCallNotes.tenantId, tenantId))
-      .orderBy(desc(discoveryCallNotes.createdAt))
-      .limit(1);
-
-    const summarySnippet = discoveryNote?.notes
-      ? discoveryNote.notes.substring(0, 250) + (discoveryNote.notes.length > 250 ? '...' : '')
-      : '';
-
-    // 6. DIAGNOSTICS (SOP outputs)
-    const sopOutputs = await db
-      .select({
-        id: tenantDocuments.id,
-        title: tenantDocuments.title,
-        createdAt: tenantDocuments.createdAt,
-      })
-      .from(tenantDocuments)
-      .where(
-        and(
-          eq(tenantDocuments.tenantId, tenantId),
-          eq(tenantDocuments.category, 'sop_output')
-        )
-      )
-      .orderBy(desc(tenantDocuments.createdAt));
-
-    // 7. ROADMAPS
-    const roadmapsData = await db
-      .select()
-      .from(roadmaps)
-      .where(eq(roadmaps.tenantId, tenantId))
-      .orderBy(desc(roadmaps.createdAt));
-
-    const lastRoadmap = roadmapsData[0] || null;
-
-    // 8. TICKETS
-    const [ticketPackData] = await db
-      .select()
-      .from(ticketPacks)
-      .where(eq(ticketPacks.tenantId, tenantId))
-      .orderBy(desc(ticketPacks.createdAt))
-      .limit(1);
-
-    let ticketInstData: any[] = [];
-    let ticketsTotalsByStatus = { not_started: 0, in_progress: 0, blocked: 0, done: 0, skipped: 0 };
-
-    if (ticketPackData) {
-      ticketInstData = await db
-        .select()
-        .from(ticketInstances)
-        .where(eq(ticketInstances.ticketPackId, ticketPackData.id));
-
-      ticketInstData.forEach((ti) => {
-        const status = ti.status as keyof typeof ticketsTotalsByStatus;
-        if (ticketsTotalsByStatus[status] !== undefined) {
-          ticketsTotalsByStatus[status]++;
-        }
-      });
-    }
-
-    // 9. IMPLEMENTATION SNAPSHOTS + OUTCOMES
-    const baselineSnapshot = await db
-      .select()
-      .from(implementationSnapshots)
-      .where(
-        and(
-          eq(implementationSnapshots.tenantId, tenantId),
-          eq(implementationSnapshots.label, 'baseline')
-        )
-      )
-      .orderBy(desc(implementationSnapshots.snapshotDate))
-      .limit(1);
-
-    const latestSnapshot = await db
-      .select()
-      .from(implementationSnapshots)
-      .where(eq(implementationSnapshots.tenantId, tenantId))
-      .orderBy(desc(implementationSnapshots.snapshotDate))
-      .limit(1);
-
-    const [outcomeData] = await db
-      .select()
-      .from(roadmapOutcomes)
-      .where(eq(roadmapOutcomes.tenantId, tenantId))
-      .orderBy(desc(roadmapOutcomes.createdAt))
-      .limit(1);
-
-    // 10. DOCUMENTS (categorized counts + recent)
-    const documentsByCategory = await db
-      .select({
-        category: tenantDocuments.category,
-        count: sql<number>`COUNT(*)`,
-      })
-      .from(tenantDocuments)
-      .where(eq(tenantDocuments.tenantId, tenantId))
-      .groupBy(tenantDocuments.category);
-
-    const docTotalsByCategory: Record<string, number> = {};
-    documentsByCategory.forEach((row) => {
-      docTotalsByCategory[row.category] = Number(row.count);
-    });
-
-    const recentDocuments = await db
-      .select({
-        id: tenantDocuments.id,
-        title: tenantDocuments.title,
-        category: tenantDocuments.category,
-        createdAt: tenantDocuments.createdAt,
-      })
-      .from(tenantDocuments)
-      .where(eq(tenantDocuments.tenantId, tenantId))
-      .orderBy(desc(tenantDocuments.createdAt))
-      .limit(5);
-
-    // 11. AGENTS (configs + threads)
-    const agentConfigsData = await db
-      .select({
-        id: agentConfigs.id,
-        agentType: agentConfigs.agentType,
-        isActive: agentConfigs.isActive,
-        lastProvisionedAt: agentConfigs.lastProvisionedAt,
-      })
-      .from(agentConfigs)
-      .where(eq(agentConfigs.tenantId, tenantId));
-
-    const activeConfigs = agentConfigsData.filter((c) => c.isActive).length;
-
-    const agentThreadsData = await db
-      .select({
-        id: agentThreads.id,
-        roleType: agentThreads.roleType,
-        lastActivityAt: agentThreads.lastActivityAt,
-      })
-      .from(agentThreads)
-      .where(eq(agentThreads.tenantId, tenantId))
-      .orderBy(desc(agentThreads.lastActivityAt))
-      .limit(10);
-
-    // Assemble response
-    const response = {
-      tenant: {
-        id: tenantRow.tenantId,
-        name: tenantRow.tenantName,
-        businessType: tenantRow.businessType,
-        status: tenantRow.status,
-        cohortLabel: tenantRow.cohortLabel,
-        segment: tenantRow.segment,
-        region: tenantRow.region,
-        firmSizeTier: tenantRow.firmSizeTier,
-        teamHeadcount: tenantRow.teamHeadcount,
-        baselineMonthlyLeads: tenantRow.baselineMonthlyLeads,
-        discoveryComplete: tenantRow.discoveryComplete,
-        notes: tenantRow.notes,
-        lastDiagnosticId: tenantRow.lastDiagnosticId,
-        createdAt: tenantRow.tenantCreatedAt,
-        updatedAt: tenantRow.tenantUpdatedAt,
-        ownerUserId: tenantRow.ownerUserId,
-        intakeWindowState: tenantRow.intakeWindowState,
-        executiveBriefStatus: briefStatus,
-        executionPhase,
-      },
-
-
-      engagementSummary: {
-        last30d: {
-          intakeCompleted: Number(metricsLast30d[0]?.intakeCompleted || 0),
-          roadmapsDelivered: Number(metricsLast30d[0]?.roadmapsDelivered || 0),
-        },
-        lifetime: {
-          intakeCompleted: Number(metricsLifetime[0]?.intakeCompleted || 0),
-          roadmapsDelivered: Number(metricsLifetime[0]?.roadmapsDelivered || 0),
-        },
-      },
-      intakes: {
-        byRole: intakesByRole,
-      },
-      discovery: {
-        hasDiscoveryNotes: !!discoveryNote,
-        summarySnippet,
-        lastUpdatedAt: discoveryNote?.updatedAt || null,
-      },
-      diagnostics: {
-        sopOutputs,
-      },
-      roadmaps: {
-        total: roadmapsData.length,
-        lastRoadmap: lastRoadmap
-          ? {
-            id: lastRoadmap.id,
-            status: lastRoadmap.status,
-            deliveredAt: lastRoadmap.deliveredAt,
-            createdAt: lastRoadmap.createdAt,
-          }
-          : null,
-      },
-      tickets: {
-        hasTicketPack: !!ticketPackData,
-        ticketPack: ticketPackData
-          ? {
-            id: ticketPackData.id,
-            version: ticketPackData.version,
-            status: ticketPackData.status,
-            totalTickets: ticketPackData.totalTickets,
-            totalSprints: ticketPackData.totalSprints,
-            totalsByStatus: ticketsTotalsByStatus,
-          }
-          : null,
-        instances: ticketInstData.slice(0, 10).map((ti) => ({
-          id: ti.id,
-          ticketId: ti.ticketId,
-          status: ti.status,
-          completedAt: ti.completedAt,
-        })),
-      },
-      implementation: {
-        baselineSnapshot: baselineSnapshot[0]
-          ? {
-            id: baselineSnapshot[0].id,
-            snapshotDate: baselineSnapshot[0].snapshotDate,
-            metrics: baselineSnapshot[0].metrics,
-          }
-          : null,
-        latestSnapshot: latestSnapshot[0]
-          ? {
-            id: latestSnapshot[0].id,
-            label: latestSnapshot[0].label,
-            snapshotDate: latestSnapshot[0].snapshotDate,
-            metrics: latestSnapshot[0].metrics,
-          }
-          : null,
-        outcomes: outcomeData
-          ? {
-            id: outcomeData.id,
-            status: outcomeData.status,
-            deltas: outcomeData.deltas,
-            realizedRoi: outcomeData.realizedRoi,
-            updatedAt: outcomeData.updatedAt,
-          }
-          : null,
-      },
-      documents: {
-        totalsByCategory: docTotalsByCategory,
-        recent: recentDocuments,
-      },
-      agents: {
-        totalConfigs: agentConfigsData.length,
-        activeConfigs,
-        recentThreads: agentThreadsData,
-      },
-      latestRoadmap: lastRoadmap, // Canonical source of truth
-    };
-
-    return res.json(response);
-  } catch (error) {
-    console.error('Get firm detail v2 error:', error);
-    return res.status(500).json({ error: 'Failed to fetch firm detail v2' });
-  }
-}
-
-// ============================================================================
-// PATCH /api/superadmin/firms/:tenantId - Update Tenant
-// ============================================================================
-
-export async function updateFirmStatus(req: AuthRequest, res: Response) {
-  try {
-    if (!requireSuperAdmin(req, res)) return;
-
-    const { tenantId } = req.params;
-    const { name, cohortLabel, segment, region, status, notes } = req.body;
-
-    const updates: any = { updatedAt: new Date() };
-    if (name !== undefined) updates.name = name;
-    if (cohortLabel !== undefined) updates.cohortLabel = cohortLabel;
-    if (segment !== undefined) updates.segment = segment;
-    if (region !== undefined) updates.region = region;
-    if (status !== undefined) updates.status = status;
-    if (notes !== undefined) updates.notes = notes;
-
-    if (Object.keys(updates).length === 1) { // only updatedAt
-      return res.status(400).json({ error: 'No updates provided' });
-    }
-
-    const [updated] = await db
-      .update(tenants)
-      .set(updates)
-      .where(eq(tenants.id, tenantId))
-      .returning();
-
-    if (!updated) {
-      return res.status(404).json({ error: 'Firm not found' });
-    }
-
-    // Log audit event
-    await db.insert(auditEvents).values({
-      tenantId,
-      actorUserId: req.user!.userId,
-      actorRole: req.user!.role,
-      eventType: 'TENANT_UPDATED',
-      entityType: 'tenant',
-      entityId: tenantId,
-      metadata: { updates },
-    });
-
-    return res.json({ tenant: updated });
-  } catch (error) {
-    console.error('Update firm status error:', error);
-    return res.status(500).json({ error: 'Failed to update firm status' });
-  }
-}
-
-// ============================================================================
-// GET /api/superadmin/export/intakes - Export All Intakes
-// ============================================================================
-
-export async function exportIntakes(req: AuthRequest, res: Response) {
-  try {
-    if (!requireSuperAdmin(req, res)) return;
-
-    const format = (req.query.format as string) || 'json';
-    const cohortFilter = req.query.cohortLabel as string | undefined;
-
-    // Get all intakes with user and tenant info
-    let query = db
-      .select({
-        intakeId: intakes.id,
-        role: intakes.role,
-        status: intakes.status,
-        answers: intakes.answers,
-        completedAt: intakes.completedAt,
-        intakeCreatedAt: intakes.createdAt,
-        userId: users.id,
-        userName: users.name,
-        userEmail: users.email,
-        userRole: users.role,
-        userCreatedAt: users.createdAt,
-        tenantId: tenants.id,
-        tenantName: tenants.name,
-        cohortLabel: tenants.cohortLabel,
-        segment: tenants.segment,
-        region: tenants.region,
-        tenantStatus: tenants.status,
-        tenantCreatedAt: tenants.createdAt,
-      })
-      .from(intakes)
-      .innerJoin(users, eq(intakes.userId, users.id))
-      .innerJoin(tenants, eq(intakes.tenantId, tenants.id));
-
-    const allIntakes = cohortFilter
-      ? await query.where(eq(tenants.cohortLabel, cohortFilter))
-      : await query;
-
-    // Get team member counts for each tenant
-    const tenantTeamCounts = new Map<string, number>();
-    const uniqueTenantIds = [...new Set(allIntakes.map(i => i.tenantId))];
-
-    for (const tid of uniqueTenantIds) {
-      const [{ count: teamCount }] = await db
-        .select({ count: count() })
-        .from(users)
-        .where(eq(users.tenantId, tid));
-
-      tenantTeamCounts.set(tid, teamCount || 0);
-    }
-
-    // Log audit event
-    await db.insert(auditEvents).values({
-      tenantId: null,
-      actorUserId: req.user!.userId,
-      actorRole: req.user!.role,
-      eventType: 'INTAKES_EXPORTED',
-      entityType: 'intake',
-      entityId: null,
-      metadata: { format, cohortFilter, count: allIntakes.length },
-    });
-
-    if (format === 'csv') {
-      // Flatten answers for CSV - get all unique question keys
-      const allQuestionKeys = new Set<string>();
-      allIntakes.forEach(intake => {
-        if (intake.answers && typeof intake.answers === 'object') {
-          Object.keys(intake.answers).forEach(key => allQuestionKeys.add(key));
-        }
-      });
-      const questionKeysArray = Array.from(allQuestionKeys).sort();
-
-      const csvRows: string[] = [];
-
-      // Header row
-      const headers = [
-        'Intake ID',
-        'Tenant Name',
-        'Cohort',
-        'Segment',
-        'Region',
-        'Tenant Status',
-        'Tenant Created',
-        'Team Size',
-        'Team Member Name',
-        'Team Member Email',
-        'Team Member Role',
-        'Team Member Joined',
-        'Intake Role',
-        'Intake Status',
-        'Intake Started',
-        'Intake Completed',
-        ...questionKeysArray,
-      ];
-      csvRows.push(headers.join(','));
-
-      // Data rows
-      for (const intake of allIntakes) {
-        const answers = intake.answers as Record<string, any> || {};
-        const answerValues = questionKeysArray.map(key => {
-          const val = answers[key];
-          if (val === null || val === undefined) return '';
-          const strVal = typeof val === 'object' ? JSON.stringify(val) : String(val);
-          return `"${strVal.replace(/"/g, '""')}"`;
-        });
-
-        csvRows.push([
-          intake.intakeId,
-          `"${intake.tenantName.replace(/"/g, '""')}"`,
-          intake.cohortLabel || '',
-          intake.segment || '',
-          intake.region || '',
-          intake.tenantStatus,
-          new Date(intake.tenantCreatedAt).toISOString().split('T')[0],
-          String(tenantTeamCounts.get(intake.tenantId) || 0),
-          `"${intake.userName.replace(/"/g, '""')}"`,
-          intake.userEmail,
-          intake.userRole,
-          new Date(intake.userCreatedAt).toISOString().split('T')[0],
-          intake.role,
-          intake.status || 'in_progress',
-          new Date(intake.intakeCreatedAt).toISOString().split('T')[0],
-          intake.completedAt ? new Date(intake.completedAt).toISOString().split('T')[0] : '',
-          ...answerValues,
-        ].join(','));
-      }
-
-      res.setHeader('Content-Type', 'text/csv; charset=utf-8');
-      res.setHeader('Content-Disposition', `attachment; filename="intakes-export-${new Date().toISOString().split('T')[0]}.csv"`);
-      return res.send(csvRows.join('\n'));
-    } else {
-      // Return structured JSON with nice formatting
-      const formattedIntakes = allIntakes.map(intake => ({
-        intake: {
-          id: intake.intakeId,
-          role: intake.role,
-          status: intake.status || 'in_progress',
-          started: intake.intakeCreatedAt,
-          completed: intake.completedAt,
-          answers: intake.answers,
-        },
-        teamMember: {
-          id: intake.userId,
-          name: intake.userName,
-          email: intake.userEmail,
-          role: intake.userRole,
-          joinedAt: intake.userCreatedAt,
-        },
-        tenant: {
-          id: intake.tenantId,
-          name: intake.tenantName,
-          cohort: intake.cohortLabel,
-          segment: intake.segment,
-          region: intake.region,
-          status: intake.tenantStatus,
-          createdAt: intake.tenantCreatedAt,
-          teamSize: tenantTeamCounts.get(intake.tenantId) || 0,
-        },
-      }));
-
-      res.setHeader('Content-Type', 'application/json');
-      res.setHeader('Content-Disposition', `attachment; filename="intakes-export-${new Date().toISOString().split('T')[0]}.json"`);
-      return res.json({
-        exportedAt: new Date().toISOString(),
-        totalIntakes: allIntakes.length,
-        cohortFilter: cohortFilter || null,
-        data: formattedIntakes,
-      });
-    }
-  } catch (error) {
-    console.error('Export intakes error:', error);
-    return res.status(500).json({ error: 'Failed to export intakes' });
-  }
-}
-
-// ============================================================================
-// GET /api/superadmin/export/firms/:tenantId/intakes - Export Single Firm Intakes
-// ============================================================================
-
-export async function exportFirmIntakes(req: AuthRequest, res: Response) {
-  try {
-    if (!requireSuperAdmin(req, res)) return;
-
-    const { tenantId } = req.params;
-    const format = (req.query.format as string) || 'json';
-
-    // Get tenant info with full details
-    const [tenantData] = await db
-      .select({
-        tenantId: tenants.id,
-        tenantName: tenants.name,
-        ownerUserId: tenants.ownerUserId,
-        cohortLabel: tenants.cohortLabel,
-        segment: tenants.segment,
-        region: tenants.region,
-        status: tenants.status,
-        createdAt: tenants.createdAt,
-      })
-      .from(tenants)
-      .where(eq(tenants.id, tenantId))
-      .limit(1);
-
-    if (!tenantData) {
-      return res.status(404).json({ error: 'Firm not found' });
-    }
-
-    // Get all team members for this firm
-    const teamMembers = await db
-      .select({
-        id: users.id,
-        name: users.name,
-        email: users.email,
-        role: users.role,
-        createdAt: users.createdAt,
-      })
-      .from(users)
-      .where(eq(users.tenantId, tenantId));
-
-    // Get intakes for this firm with user details
-    const firmIntakes = await db
-      .select({
-        intakeId: intakes.id,
-        role: intakes.role,
-        status: intakes.status,
-        answers: intakes.answers,
-        completedAt: intakes.completedAt,
-        intakeCreatedAt: intakes.createdAt,
-        userId: users.id,
-        userName: users.name,
-        userEmail: users.email,
-        userRole: users.role,
-        userCreatedAt: users.createdAt,
-      })
-      .from(intakes)
-      .innerJoin(users, eq(intakes.userId, users.id))
-      .where(eq(intakes.tenantId, tenantId));
-
-    // Log audit event
-    await db.insert(auditEvents).values({
-      tenantId,
-      actorUserId: req.user!.userId,
-      actorRole: req.user!.role,
-      eventType: 'FIRM_INTAKES_EXPORTED',
-      entityType: 'intake',
-      entityId: null,
-      metadata: { format, count: firmIntakes.length },
-    });
-
-    if (format === 'csv') {
-      // Flatten answers for CSV - get all unique question keys
-      const allQuestionKeys = new Set<string>();
-      firmIntakes.forEach(intake => {
-        if (intake.answers && typeof intake.answers === 'object') {
-          Object.keys(intake.answers).forEach(key => allQuestionKeys.add(key));
-        }
-      });
-      const questionKeysArray = Array.from(allQuestionKeys).sort();
-
-      const csvRows: string[] = [];
-
-      // Header row
-      const headers = [
-        'Intake ID',
-        'Team Member Name',
-        'Team Member Email',
-        'Team Member Role',
-        'Team Member Joined',
-        'Intake Role',
-        'Intake Status',
-        'Intake Started',
-        'Intake Completed',
-        ...questionKeysArray,
-      ];
-      csvRows.push(headers.join(','));
-
-      // Data rows
-      for (const intake of firmIntakes) {
-        const answers = intake.answers as Record<string, any> || {};
-        const answerValues = questionKeysArray.map(key => {
-          const val = answers[key];
-          if (val === null || val === undefined) return '';
-          const strVal = typeof val === 'object' ? JSON.stringify(val) : String(val);
-          return `"${strVal.replace(/"/g, '""')}"`;
-        });
-
-        csvRows.push([
-          intake.intakeId,
-          `"${intake.userName.replace(/"/g, '""')}"`,
-          intake.userEmail,
-          intake.userRole,
-          new Date(intake.userCreatedAt).toISOString().split('T')[0],
-          intake.role,
-          intake.status || 'in_progress',
-          new Date(intake.intakeCreatedAt).toISOString().split('T')[0],
-          intake.completedAt ? new Date(intake.completedAt).toISOString().split('T')[0] : '',
-          ...answerValues,
-        ].join(','));
-      }
-
-      res.setHeader('Content-Type', 'text/csv; charset=utf-8');
-      res.setHeader('Content-Disposition', `attachment; filename="${tenantData.tenantName.replace(/[^a-z0-9]/gi, '_')}-intakes-${new Date().toISOString().split('T')[0]}.csv"`);
-      return res.send(csvRows.join('\n'));
-    } else {
-      // Return structured JSON with nice formatting
-      const formattedData = {
-        exportedAt: new Date().toISOString(),
-        tenant: {
-          id: tenantData.tenantId,
-          name: tenantData.tenantName,
-          cohort: tenantData.cohortLabel,
-          segment: tenantData.segment,
-          region: tenantData.region,
-          status: tenantData.status,
-          createdAt: tenantData.createdAt,
-        },
-        teamMembers: teamMembers.map(member => ({
-          id: member.id,
-          name: member.name,
-          email: member.email,
-          role: member.role,
-          joinedAt: member.createdAt,
-          hasCompletedIntake: firmIntakes.some(i => i.userId === member.id),
-        })),
-        intakes: firmIntakes.map(intake => ({
-          id: intake.intakeId,
-          teamMember: {
-            id: intake.userId,
-            name: intake.userName,
-            email: intake.userEmail,
-            role: intake.userRole,
-          },
-          intakeRole: intake.role,
-          status: intake.status || 'in_progress',
-          started: intake.intakeCreatedAt,
-          completed: intake.completedAt,
-          answers: intake.answers,
-        })),
-        summary: {
-          totalTeamMembers: teamMembers.length,
-          totalIntakes: firmIntakes.length,
-          completedIntakes: firmIntakes.filter(i => i.completedAt).length,
-          intakesByRole: firmIntakes.reduce((acc, intake) => {
-            acc[intake.role] = (acc[intake.role] || 0) + 1;
-            return acc;
-          }, {} as Record<string, number>),
-        },
-      };
-
-      res.setHeader('Content-Type', 'application/json');
-      res.setHeader('Content-Disposition', `attachment; filename="${tenantData.tenantName.replace(/[^a-z0-9]/gi, '_')}-intakes-${new Date().toISOString().split('T')[0]}.json"`);
-      return res.json(formattedData);
-    }
-  } catch (error) {
-    console.error('Export firm intakes error:', error);
-    return res.status(500).json({ error: 'Failed to export firm intakes' });
-  }
-}
-
-// ============================================================================
-// POST /api/superadmin/firms/:tenantId/documents/upload - Upload Document for Tenant
-// ============================================================================
-
-export async function uploadDocumentForTenant(req: AuthRequest, res: Response) {
-  try {
-    if (!requireSuperAdmin(req, res)) return;
-
-    const { tenantId } = req.params;
-
-    // Check if file was uploaded
-    if (!req.file) {
-      return res.status(400).json({ error: 'No file uploaded' });
-    }
-
-    const { category, title, description, sopNumber, outputNumber, isPublic } = req.body;
-
-    if (!category || !title) {
-      return res.status(400).json({ error: 'Category and title are required' });
-    }
-
-    // Get tenant info
-    const [tenant] = await db
-      .select()
-      .from(tenants)
-      .where(eq(tenants.id, tenantId))
-      .limit(1);
-
-    if (!tenant) {
-      return res.status(404).json({ error: 'Tenant not found' });
-    }
-
-    // Ensure uploads directory exists
-    await fs.mkdir(UPLOADS_DIR, { recursive: true });
-
-    // Generate unique filename
-    const fileExt = path.extname(req.file.originalname);
-    const filename = `${Date.now()}-${Math.random().toString(36).substring(7)}${fileExt}`;
-    const filePath = filename;
-    const fullPath = path.join(UPLOADS_DIR, filePath);
-
-    // Move file from temp location to uploads directory
-    await fs.rename(req.file.path, fullPath);
-
-    // Insert document record
-    const [document] = await db
-      .insert(tenantDocuments)
-      .values({
-        tenantId: tenant.id,
-        ownerUserId: tenant.ownerUserId,
-        filename,
-        originalFilename: req.file.originalname,
-        filePath,
-        fileSize: req.file.size,
-        mimeType: req.file.mimetype,
-        category,
-        title,
-        description: description || null,
-
-        uploadedBy: req.user!.userId,
-        isPublic: isPublic === 'true' || isPublic === true,
-      })
-      .returning();
-
-    // Log audit event
-    await db.insert(auditEvents).values({
-      tenantId,
-      actorUserId: req.user!.userId,
-      actorRole: req.user!.role,
-      eventType: 'DOCUMENT_UPLOADED',
-      entityType: 'tenant_document',
-      entityId: document.id,
-      metadata: {
-        filename: req.file.originalname,
-        category,
-        sopNumber,
-        outputNumber,
-      },
-    });
-
-    // Auto-refresh vector store after document upload (non-blocking)
-    refreshVectorStoreContent(tenantId)
-      .then(() => console.log('[Upload] Vector store refreshed successfully'))
-      .catch((error: any) => console.warn('[Upload] Vector store refresh failed:', error.message));
-
-    return res.json({ document });
-  } catch (error) {
-    console.error('Upload document for tenant error:', error);
-    return res.status(500).json({ error: 'Failed to upload document' });
-  }
-}
-
-// ============================================================================
-// GET /api/superadmin/firms/:tenantId/documents - List Documents for Tenant
-// ============================================================================
-
-export async function listTenantDocuments(req: AuthRequest, res: Response) {
-  try {
-    if (!requireSuperAdmin(req, res)) return;
-
-    const { tenantId } = req.params;
-
-    // Get documents for this tenant
-    const documents = await db
-      .select()
-      .from(tenantDocuments)
-      .where(eq(tenantDocuments.tenantId, tenantId))
-      .orderBy(desc(tenantDocuments.createdAt));
-
-    return res.json({ documents });
-  } catch (error) {
-    console.error('List tenant documents error:', error);
-    return res.status(500).json({ error: 'Failed to list documents' });
-  }
-}
-
-// ============================================================================
-// GET /api/superadmin/firms/:tenantId/workflow-status - Firm Workflow Status
-// ============================================================================
-
-export async function getFirmWorkflowStatus(req: AuthRequest, res: Response) {
-  try {
-    if (!requireSuperAdmin(req, res)) return;
-
-    const { tenantId } = req.params;
-
-    // Check if tenant exists
-    const [tenant] = await db
-      .select()
-      .from(tenants)
-      .where(eq(tenants.id, tenantId))
-      .limit(1);
-
-    if (!tenant) {
-      return res.status(404).json({ error: 'Tenant not found' });
-    }
-
-    // 1. Query intakes for this tenant
-    const allIntakes = await db
-      .select()
-      .from(intakes)
-      .where(eq(intakes.tenantId, tenantId));
-
-    const rolesCompleted = new Set(
-      allIntakes.filter(i => i.completedAt).map(i => i.role)
-    );
-    const requiredRoles = ['owner', 'ops', 'sales', 'delivery'];
-    const intakesComplete = requiredRoles.every(role => rolesCompleted.has(role));
-
-    // 2. Query SOP-01 documents
-    const sop01Docs = await db
-      .select()
-      .from(tenantDocuments)
-      .where(and(
-        eq(tenantDocuments.tenantId, tenantId),
-        eq(tenantDocuments.sopNumber, 'SOP-01')
-      ));
-
-    const requiredOutputs = ['Output-1', 'Output-2', 'Output-3', 'Output-4'];
-    const sop01Complete = requiredOutputs.every(out =>
-      sop01Docs.some(d => d.outputNumber === out)
-    );
-
-    // 3. Query discovery call notes
-    const [discoveryNote] = await db
-      .select()
-      .from(discoveryCallNotes)
-      .where(eq(discoveryCallNotes.tenantId, tenantId))
-      .orderBy(desc(discoveryCallNotes.createdAt))
-      .limit(1);
-
-    const discoveryComplete = !!discoveryNote && !!tenant.discoveryComplete;
-
-    // 4. Query roadmap documents
-    const roadmapDocs = await db
-      .select()
-      .from(tenantDocuments)
-      .where(and(
-        eq(tenantDocuments.tenantId, tenantId),
-        eq(tenantDocuments.category, 'roadmap')
-      ));
-
-    const requiredSections = [
-      'summary',
-      '01-executive-summary',
-      '02-diagnostic-analysis',
-      '03-system-architecture',
-      '04-high-leverage-systems',
-      '05-implementation-plan',
-      '06-sop-pack',
-      '07-metrics-dashboard',
-      '08-appendix',
-    ];
-    const roadmapComplete = requiredSections.every(section =>
-      roadmapDocs.some(d => d.section === section)
-    );
-
-    return res.json({
-      intakes: {
-        complete: intakesComplete,
-        rolesCompleted: Array.from(rolesCompleted),
-        totalIntakes: allIntakes.length,
-      },
-      sop01: {
-        complete: sop01Complete,
-        documents: sop01Docs.map(d => ({
-          id: d.id,
-          outputNumber: d.outputNumber,
-        })),
-      },
-      discovery: {
-        complete: discoveryComplete,
-        hasNotes: !!discoveryNote,
-        lastUpdatedAt: discoveryNote?.updatedAt?.toISOString() || null,
-      },
-      roadmap: {
-        complete: roadmapComplete,
-        sectionsCount: roadmapDocs.length,
-      },
-    });
-  } catch (error) {
-    console.error('Get firm workflow status error:', error);
-    return res.status(500).json({ error: 'Failed to get workflow status' });
-  }
-}
-
-
-
-
-
-// ============================================================================
-// POST /api/superadmin/firms/:tenantId/generate-roadmap - Generate Roadmap (SOP-03)
-// ============================================================================
-
-// ============================================================================
-// GET /api/superadmin/firms/:tenantId/roadmap-os - Get Roadmap OS View
-// ============================================================================
-
-export async function getRoadmapOsForFirm(req: AuthRequest, res: Response) {
-  try {
-    if (!requireSuperAdmin(req, res)) return;
-
-    const { tenantId } = req.params;
-
-    // Get roadmap for tenant
-    const roadmap = await getOrCreateRoadmapForTenant(tenantId);
-
-    // Get all sections
-    const sections = await db
-      .select()
-      .from(roadmapSections)
-      .where(eq(roadmapSections.roadmapId, roadmap.id))
-      .orderBy(asc(roadmapSections.sectionNumber));
-
-    return res.json({
-      roadmap: {
-        id: roadmap.id,
-        tenantId: roadmap.tenantId,
-        status: roadmap.status,
-        pilotStage: roadmap.pilotStage,
-        createdAt: roadmap.createdAt,
-      },
-      sections: sections.map(s => ({
-        id: s.id,
-        sectionNumber: s.sectionNumber,
-        sectionName: s.sectionName,
-        status: s.status,
-        wordCount: s.wordCount,
-        lastUpdatedAt: s.lastUpdatedAt,
-        contentMarkdown: s.contentMarkdown, // Include for modal viewing
-      })),
-    });
-  } catch (error: any) {
-    console.error('Get roadmap OS for firm error:', error);
-    return res.status(500).json({ error: 'Failed to get roadmap OS' });
-  }
-}
-
-// ============================================================================
-// GET /api/superadmin/firms/:tenantId/tickets - Get Ticket Pack with Sections
-// ============================================================================
-
-export async function getTicketsForFirm(req: AuthRequest, res: Response) {
-  try {
-    if (!requireSuperAdmin(req, res)) return;
-
-    const { tenantId } = req.params;
-
-    // Get roadmap
-    const roadmap = await getOrCreateRoadmapForTenant(tenantId);
-
-    // Get ticket pack
-    const pack = await db.query.ticketPacks.findFirst({
-      where: eq(ticketPacks.roadmapId, roadmap.id),
-    });
-
-    if (!pack) {
-      return res.json({ ticketPack: null, sections: [] });
-    }
-
-    // Get all tickets
-    const tickets = await db
-      .select()
-      .from(ticketInstances)
-      .where(eq(ticketInstances.ticketPackId, pack.id));
-
-    // Get all sections
-    const sections = await db
-      .select()
-      .from(roadmapSections)
-      .where(eq(roadmapSections.roadmapId, roadmap.id))
-      .orderBy(asc(roadmapSections.sectionNumber));
-
-    // Group tickets by section
-    const sectionsWithTickets = sections.map(section => {
-      const sectionTickets = tickets.filter(t => t.sectionNumber === section.sectionNumber);
-      const total = sectionTickets.length;
-      const done = sectionTickets.filter(t => t.status === 'done').length;
-
-      return {
-        sectionNumber: section.sectionNumber,
-        sectionName: section.sectionName,
-        status: section.status,
-        tickets: sectionTickets.map(t => ({
-          id: t.id,
-          ticketId: t.ticketId,
-          status: t.status,
-          assignee: t.assignee,
-          notes: t.notes,
-          startedAt: t.startedAt,
-          completedAt: t.completedAt,
-        })),
-        progress: total > 0 ? Math.round((done / total) * 100) : 0,
-        totalTickets: total,
-        doneTickets: done,
-      };
-    });
-
-    return res.json({
-      ticketPack: {
-        id: pack.id,
-        status: pack.status,
-        totalTickets: pack.totalTickets,
-        totals: pack.totals,
-      },
-      sections: sectionsWithTickets,
-    });
-  } catch (error: any) {
-    console.error('Get tickets for firm error:', error);
-    return res.status(500).json({ error: error.message || 'Failed to get tickets' });
-  }
-}
-
-// ============================================================================
-// POST /api/superadmin/firms/:tenantId/generate-tickets - Generate Ticket Pack
-// ============================================================================
-
-export async function generateTicketsForFirm(req: AuthRequest, res: Response) {
-  try {
-    if (!requireSuperAdmin(req, res)) return;
-
-    const { tenantId } = req.params;
-
-    // Get roadmap for tenant
-    const roadmap = await getOrCreateRoadmapForTenant(tenantId);
-
-    // Generate ticket pack
-    const result = await generateTicketPackForRoadmap(roadmap.id, tenantId);
-
-    return res.json({
-      ok: true,
-      ticketPackId: result.ticketPackId,
-      ticketsGenerated: result.ticketsGenerated,
-    });
-  } catch (error: any) {
-    console.error('Generate tickets for firm error:', error);
-    return res.status(500).json({ error: error.message || 'Failed to generate tickets' });
-  }
-}
-
-// ============================================================================
-// POST /api/superadmin/firms/:tenantId/extract-metadata - Extract Roadmap Metadata
-// ============================================================================
-
-export async function extractMetadataForFirm(req: AuthRequest, res: Response) {
-  try {
-    if (!requireSuperAdmin(req, res)) return;
-
-    const { tenantId } = req.params;
-
-    // Get roadmap for tenant
-    const roadmap = await getOrCreateRoadmapForTenant(tenantId);
-
-    // Extract metadata and update agent configs
-    const metadata = await extractRoadmapMetadata(roadmap.id, tenantId);
-
-    return res.json({
-      ok: true,
-      metadata,
-    });
-  } catch (error: any) {
-    console.error('Extract metadata for firm error:', error);
-    return res.status(500).json({ error: error.message || 'Failed to extract metadata' });
-  }
-}
-
-// ============================================================================
-// GET /api/superadmin/firms/:tenantId/metrics - Get Performance Metrics (T3.7)
-// ============================================================================
-
-export async function getMetricsForFirm(req: AuthRequest, res: Response) {
-  try {
-    if (!requireSuperAdmin(req, res)) return;
-
-    const { tenantId } = req.params;
-
-    // Get roadmap
-    const roadmap = await getOrCreateRoadmapForTenant(tenantId);
-
-    // Get all snapshots
-    const snapshots = await ImplementationMetricsService.getSnapshotsForRoadmap({
-      tenantId,
-      roadmapId: roadmap.id,
-    });
-
-    // Get outcome (with deltas + ROI)
-    const outcome = await ImplementationMetricsService.getOutcome({
-      tenantId,
-      roadmapId: roadmap.id,
-    });
-
-    return res.json({
-      snapshots,
-      outcome: outcome || null,
-    });
-  } catch (error: any) {
-    console.error('Get metrics for firm error:', error);
-    return res.status(500).json({ error: error.message || 'Failed to get metrics' });
-  }
-}
-
-// ============================================================================
-// POST /api/superadmin/firms/:tenantId/metrics/baseline - Create Baseline (T3.2)
-// ============================================================================
-
-export async function createBaselineForFirm(req: AuthRequest, res: Response) {
-  try {
-    if (!requireSuperAdmin(req, res)) return;
-
-    const { tenantId } = req.params;
-    const { metrics, source = 'manual' } = req.body;
-
-    const roadmap = await getOrCreateRoadmapForTenant(tenantId);
-
-    const result = await ImplementationMetricsService.createBaselineSnapshot(
-      tenantId,
-      roadmap.id,
-      metrics,
-      source
-    );
-
-    return res.json({ ok: true, ...result });
-  } catch (error: any) {
-    console.error('Create baseline error:', error);
-    return res.status(500).json({ error: error.message || 'Failed to create baseline' });
-  }
-}
-
-// ============================================================================
-// POST /api/superadmin/firms/:tenantId/metrics/snapshot - Create Time Snapshot (T3.3)
-// ============================================================================
-
-export async function createSnapshotForFirm(req: AuthRequest, res: Response) {
-  try {
-    if (!requireSuperAdmin(req, res)) return;
-
-    const { tenantId } = req.params;
-    const { label, metrics, source = 'manual' } = req.body;
-
-    if (!['30d', '60d', '90d', 'custom'].includes(label)) {
-      return res.status(400).json({ error: 'Invalid label. Must be 30d, 60d, 90d, or custom' });
-    }
-
-    const roadmap = await getOrCreateRoadmapForTenant(tenantId);
-
-    const result = await ImplementationMetricsService.createTimeSnapshot(
-      tenantId,
-      roadmap.id,
-      label,
-      metrics,
-      source
-    );
-
-    return res.json({ ok: true, ...result });
-  } catch (error: any) {
-    console.error('Create snapshot error:', error);
-    return res.status(500).json({ error: error.message || 'Failed to create snapshot' });
-  }
-}
-
-// ============================================================================
-// POST /api/superadmin/firms/:tenantId/metrics/compute-outcome - Compute Deltas + ROI (T3.4, T3.5)
-// ============================================================================
-
-export async function computeOutcomeForFirm(req: AuthRequest, res: Response) {
-  try {
-    if (!requireSuperAdmin(req, res)) return;
-
-    const { tenantId } = req.params;
-    const { assumptions } = req.body;
-
-    const roadmap = await getOrCreateRoadmapForTenant(tenantId);
-
-    const outcome = await ImplementationMetricsService.createOutcomeForRoadmap({
-      tenantId,
-      roadmapId: roadmap.id,
-      assumptions,
-    });
-
-    return res.json({ ok: true, outcome });
-  } catch (error: any) {
-    console.error('Compute outcome error:', error);
-    return res.status(500).json({ error: error.message || 'Failed to compute outcome' });
-  }
-}
-
-// ============================================================================
-// POST /api/superadmin/firms/:tenantId/export/case-study - Export Case Study (T3.10)
-// ============================================================================
-
-
-
-
-
-
-// ============================================================================
-// POST /api/superadmin/tenants/:tenantId/refresh-vector-store - Manually Refresh Vector Store (V2)
-// ============================================================================
-
-export async function refreshVectorStoreForTenant(req: AuthRequest, res: Response) {
-  try {
-    if (!requireSuperAdmin(req, res)) return;
-
-    const { tenantId } = req.params;
-
-    console.log(`[SuperAdmin] Refreshing vector store for tenant: ${tenantId}`);
-
-    // Verify tenant exists
-    const tenant = await db.query.tenants.findFirst({
-      where: eq(tenants.id, tenantId),
-    });
-
-    if (!tenant) {
-      return res.status(404).json({ error: 'Tenant not found' });
-    }
-
-    // Trigger vector store refresh
-    await refreshVectorStoreContent(tenantId);
-
-    console.log(`[SuperAdmin] Vector store refreshed for: ${tenant.name}`);
-
-    return res.json({
-      ok: true,
-      message: `Vector store refreshed for ${tenant.name}`,
-      tenantId,
-    });
-  } catch (error: any) {
-    console.error('Refresh vector store error:', error);
-    return res.status(500).json({
-      error: error.message || 'Failed to refresh vector store',
-      details: error.stack,
-    });
-  }
-}
-
-// ============================================================================
-// POST /api/superadmin/firms/:tenantId/generate-roadmap - Generate Roadmap via Diagnostic Ingestion
-
-// ============================================================================
-// GET /api/superadmin/metrics/daily-rollup - 30-Day Trends (F3.3)
-// ============================================================================
-
-export async function getDailyMetricsRollup(req: AuthRequest, res: Response) {
-  try {
-    if (!requireSuperAdmin(req, res)) return;
-
-    const days = parseInt(req.query.days as string) || 30;
-
-    // Calculate date range
-    const endDate = new Date();
-    const startDate = new Date();
-    startDate.setDate(startDate.getDate() - days);
-
-    // Query tenantMetricsDaily for the date range
-    const metricsData = await db
-      .select()
-      .from(tenantMetricsDaily)
-      .where(
-        sql`${tenantMetricsDaily.metricDate} >= ${startDate.toISOString().split('T')[0]}`
-      )
-      .orderBy(asc(tenantMetricsDaily.metricDate));
-
-    // Aggregate by date
-    const dailyAggregates = metricsData.reduce((acc, row) => {
-      const dateKey = row.metricDate;
-      if (!acc[dateKey]) {
-        acc[dateKey] = {
-          date: dateKey,
-          intakeStarted: 0,
-          intakeCompleted: 0,
-          roadmapCreated: 0,
-          roadmapDelivered: 0,
-          pilotOpen: 0,
-          pilotWon: 0,
-        };
-      }
-      acc[dateKey].intakeStarted += row.intakeStartedCount;
-      acc[dateKey].intakeCompleted += row.intakeCompletedCount;
-      acc[dateKey].roadmapCreated += row.roadmapCreatedCount;
-      acc[dateKey].roadmapDelivered += row.roadmapDeliveredCount;
-      acc[dateKey].pilotOpen += row.pilotOpenCount;
-      acc[dateKey].pilotWon += row.pilotWonCount;
-      return acc;
-    }, {} as Record<string, any>);
-
-    const timeSeries = Object.values(dailyAggregates);
-
-    return res.json({
-      days,
-      startDate: startDate.toISOString().split('T')[0],
-      endDate: endDate.toISOString().split('T')[0],
-      timeSeries,
-    });
-  } catch (error) {
-    console.error('Get daily metrics rollup error:', error);
-    return res.status(500).json({ error: 'Failed to fetch daily metrics rollup' });
-  }
-}
-
-// ============================================================================
-// GET /api/superadmin/leads - View all lead request submissions
-// ============================================================================
-
-export async function getLeadRequests(req: AuthRequest, res: Response) {
-  try {
-    if (!requireSuperAdmin(req, res)) return;
-
-    const status = req.query.status as string | undefined;
-    const source = req.query.source as string | undefined;
-
-    let query = db.select().from(webinarRegistrations);
-
-    if (status) {
-      query = query.where(eq(webinarRegistrations.status, status)) as any;
-    }
-    if (source) {
-      query = query.where(eq(webinarRegistrations.source, source)) as any;
-    }
-
-    const leads = await query.orderBy(desc(webinarRegistrations.createdAt));
-
-    return res.json({ leads });
-  } catch (error) {
-    console.error('Get lead requests error:', error);
-    return res.status(500).json({ error: 'Failed to fetch lead requests' })
-  }
-}
-
-// ============================================================================
-// PATCH /api/superadmin/leads/:id - Update lead status/notes
-// ============================================================================
-
-export async function updateLeadRequest(req: AuthRequest, res: Response) {
-  try {
-    if (!requireSuperAdmin(req, res)) return;
-
-    const leadId = req.params.id;
-    if (!leadId) {
-      return res.status(400).json({ error: 'Invalid lead ID' });
-    }
-
-    const { status, notes } = req.body;
-
-    if (!status && notes === undefined) {
-      return res.status(400).json({ error: 'Must provide status or notes' });
-    }
-
-    const updateFields: any = {};
-    if (status) updateFields.status = status;
-    if (notes !== undefined) updateFields.notes = notes;
-
-    const updated = await db
-      .update(webinarRegistrations)
-      .set(updateFields)
-      .where(eq(webinarRegistrations.id, leadId))
-      .returning();
-
-    if (!updated || updated.length === 0) {
-      return res.status(404).json({ error: 'Lead not found' });
-    }
-
-    return res.json({ ok: true, lead: updated[0] });
-  } catch (error) {
-    console.error('Update lead request error:', error);
-    return res.status(500).json({ error: 'Failed to update lead request' });
-  }
-}
-
-// ============================================================================
-// WEBINAR REGISTRATION MANAGEMENT
-// ============================================================================
-
-import bcrypt from 'bcryptjs';
-
-// GET /api/superadmin/webinar/registrations - View all webinar registrations
-export async function getWebinarRegistrations(req: AuthRequest, res: Response) {
-  try {
-    if (!requireSuperAdmin(req, res)) return;
-
-    const status = req.query.status as string | undefined;
-    const source = req.query.source as string | undefined;
-
-    let query = db.select().from(webinarRegistrations);
-
-    if (status) {
-      query = query.where(eq(webinarRegistrations.status, status)) as any;
-    }
-    if (source) {
-      query = query.where(eq(webinarRegistrations.source, source)) as any;
-    }
-
-    const registrations = await query.orderBy(desc(webinarRegistrations.createdAt));
-
-    return res.json({ registrations });
-  } catch (error) {
-    console.error('Get webinar registrations error:', error);
-    return res.status(500).json({ error: 'Failed to fetch webinar registrations' });
-  }
-}
-
-// PATCH /api/superadmin/webinar/registrations/:id - Update registration status/notes
-export async function updateWebinarRegistration(req: AuthRequest, res: Response) {
-  try {
-    if (!requireSuperAdmin(req, res)) return;
-
-    const registrationId = req.params.id;
-
-    const { status, notes } = req.body;
-
-    if (!status && notes === undefined) {
-      return res.status(400).json({ error: 'Must provide status or notes' });
-    }
-
-    const updateFields: any = {};
-    if (status) updateFields.status = status;
-    if (notes !== undefined) updateFields.notes = notes;
-
-    const updated = await db
-      .update(webinarRegistrations)
-      .set(updateFields)
-      .where(eq(webinarRegistrations.id, registrationId))
-      .returning();
-
-    if (!updated || updated.length === 0) {
-      return res.status(404).json({ error: 'Registration not found' });
-    }
-
-    return res.json({ ok: true, registration: updated[0] });
-  } catch (error) {
-    console.error('Update webinar registration error:', error);
-    return res.status(500).json({ error: 'Failed to update registration' });
-  }
-}
-
-// GET /api/superadmin/webinar/settings - Get webinar settings (password version)
-export async function getWebinarSettings(req: AuthRequest, res: Response) {
-  try {
-    if (!requireSuperAdmin(req, res)) return;
-
-    const settings = await db.select().from(webinarSettings).limit(1);
-
-    if (settings.length === 0) {
-      return res.status(404).json({ error: 'Webinar settings not found' });
-    }
-
-    return res.json({
-      passwordVersion: settings[0].passwordVersion,
-      updatedAt: settings[0].updatedAt,
-    });
-  } catch (error) {
-    console.error('Get webinar settings error:', error);
-    return res.status(500).json({ error: 'Failed to fetch webinar settings' });
-  }
-}
-
-// PATCH /api/superadmin/webinar/password - Update webinar password
-export async function updateWebinarPassword(req: AuthRequest, res: Response) {
-  try {
-    if (!requireSuperAdmin(req, res)) return;
-
-    const { newPassword } = req.body;
-
-    if (!newPassword || newPassword.trim().length < 8) {
-      return res.status(400).json({ error: 'Password must be at least 8 characters' });
-    }
-
-    // Hash the new password
-    const passwordHash = await bcrypt.hash(newPassword, 10);
-
-    // Get current settings to increment version
-    const currentSettings = await db.select().from(webinarSettings).limit(1);
-
-    if (currentSettings.length === 0) {
-      // Create initial settings if not exist
-      const created = await db
-        .insert(webinarSettings)
-        .values({
-          passwordHash,
-          passwordVersion: 1,
-          updatedAt: new Date(),
-        })
-        .returning();
-
-      return res.json({
-        ok: true,
-        passwordVersion: created[0].passwordVersion,
-        message: 'Webinar password created successfully',
-      });
-    }
-
-    // Update existing settings
-    const newVersion = currentSettings[0].passwordVersion + 1;
-
-    const updated = await db
-      .update(webinarSettings)
-      .set({
-        passwordHash,
-        passwordVersion: newVersion,
-        updatedAt: new Date(),
-      })
-      .where(eq(webinarSettings.id, currentSettings[0].id))
-      .returning();
-
-    return res.json({
-      ok: true,
-      passwordVersion: updated[0].passwordVersion,
-      message: 'Webinar password updated successfully',
-    });
-  } catch (error) {
-    console.error('Update webinar password error:', error);
-    return res.status(500).json({ error: 'Failed to update webinar password' });
-  }
-}
-
-export async function signalReadiness(req: AuthRequest, res: Response) {
-  try {
-    const { tenantId } = req.params;
-    const { signal } = req.body;
-
-    if (!requireExecutiveAuthority(req, res)) return;
-
-    const updates: any = {};
-    if (signal === 'knowledge_base') updates.knowledgeBaseReadyAt = new Date();
-    if (signal === 'roles') updates.rolesValidatedAt = new Date();
-    if (signal === 'exec') updates.execReadyAt = new Date();
-
-    if (Object.keys(updates).length > 0) {
-      await db.update(tenants).set(updates).where(eq(tenants.id, tenantId));
-    }
-
-    return res.json({ success: true });
-  } catch (error) {
-    console.error('Signal readiness error:', error);
-    return res.status(500).json({ error: 'Internal server error' });
-  }
-}
-
-
-
-
-
->>>>>>> 02e8d03 (feat: executive brief approval, state sync, and pdf delivery pipeline)
-=======
->>>>>>> 1e46cab (chore: lock executive brief render + pdf contracts)
diff --git a/backend/src/services/diagnosticIngestion.service.ts b/backend/src/services/diagnosticIngestion.service.ts
index 5a2a01c..e8466c4 100644
--- a/backend/src/services/diagnosticIngestion.service.ts
+++ b/backend/src/services/diagnosticIngestion.service.ts
@@ -1,7 +1,3 @@
-<<<<<<< HEAD
-<<<<<<< HEAD
-=======
->>>>>>> 1e46cab (chore: lock executive brief render + pdf contracts)
 import { db } from '../db';
 import { sopTickets } from '../db/schema';
 import { nanoid } from 'nanoid';
@@ -9,21 +5,14 @@ import { OpenAI } from 'openai';
 import { buildDiagnosticToTicketsPrompt, SelectedInventoryTicket } from '../trustagent/prompts/diagnosticToTickets';
 import { eq, and } from 'drizzle-orm';
 import { Sop01Outputs } from './sop01Engine';
-<<<<<<< HEAD
 import { AUTHORITY_VERSION_STAGE6 } from '../config/authorityVersions';
 import { createHash } from 'crypto';
-=======
->>>>>>> 1e46cab (chore: lock executive brief render + pdf contracts)
 
 const openai = new OpenAI({
     apiKey: process.env.OPENAI_API_KEY
 });
 
-<<<<<<< HEAD
 export interface ParsedTicket {
-=======
-interface ParsedTicket {
->>>>>>> 1e46cab (chore: lock executive brief render + pdf contracts)
     title: string;
     description: string;
     category: string;
@@ -33,10 +22,7 @@ interface ParsedTicket {
     success_metric?: string;
     roi_notes?: string;
     time_estimate_hours?: number;
-<<<<<<< HEAD
     sprint?: number;
-=======
->>>>>>> 1e46cab (chore: lock executive brief render + pdf contracts)
 }
 
 export class ArtifactNotFoundError extends Error {
@@ -51,7 +37,6 @@ export class ArtifactNotFoundError extends Error {
     }
 }
 
-<<<<<<< HEAD
 export class InventoryEmptyError extends Error {
     constructor(public debug: {
         artifactIds: string[];
@@ -80,15 +65,12 @@ export class InventoryEmptyError extends Error {
  * 2. Be retrofitted to use canonical inventory selection
  * 3. Fail with CANONICAL_REQUIRED error
  */
-=======
->>>>>>> 1e46cab (chore: lock executive brief render + pdf contracts)
 export async function ingestDiagnostic(diagnosticMap: any, sop01Content: Sop01Outputs): Promise<{
     ticketCount: number;
     roadmapSectionCount: number;
     diagnosticId?: string;
     assistantProvisioned?: boolean;
 }> {
-<<<<<<< HEAD
     // HARD BLOCK: Prevent non-canonical ticket generation in production
     const allowLegacy = process.env.ALLOW_LEGACY_INGEST === 'true';
     let tickets: ParsedTicket[] = [];
@@ -105,96 +87,16 @@ export async function ingestDiagnostic(diagnosticMap: any, sop01Content: Sop01Ou
     }
 
     console.warn('[DEPRECATED] ingestDiagnostic() called - this generates non-canonical tickets. Use generateTicketsFromDiscovery() instead.');
-=======
->>>>>>> 1e46cab (chore: lock executive brief render + pdf contracts)
     const start = Date.now();
     const tenantId = diagnosticMap.tenantId; // Expected to be present
     const diagnosticId = `diag_${nanoid()}`;
 
-<<<<<<< HEAD
     // 3. Delegate to shared logic
     try {
         tickets = await generateRawTickets(diagnosticMap.tenantId, diagnosticMap, sop01Content);
     } catch (error) {
         console.error('[DiagnosticIngestion] Key failure:', error);
         throw error;
-=======
-    // 1. Locate Truth Source / Strict Validation
-    const hasDiagnosticMap = !!sop01Content.sop01DiagnosticMarkdown;
-    const hasAiLeverageMap = !!sop01Content.sop01AiLeverageMarkdown;
-    const hasRoadmapSkeleton = !!sop01Content.sop01RoadmapSkeletonMarkdown;
-    const hasDiscoveryQuestions = !!sop01Content.sop01DiscoveryQuestionsMarkdown;
-
-    if (!hasDiagnosticMap || !hasAiLeverageMap || !hasRoadmapSkeleton || !hasDiscoveryQuestions) {
-        console.error(`[DiagnosticIngestion] Missing required SOP-01 artifacts for tenant ${tenantId}`);
-        throw new ArtifactNotFoundError({
-            hasDiagnosticMap,
-            hasAiLeverageMap,
-            hasRoadmapSkeleton,
-            hasDiscoveryQuestions
-        });
-    }
-
-    let tickets: ParsedTicket[] = [];
-
-    // 2. Prompt Construction (Strictly derived from artifacts)
-    // Map canonical fields to prompt expectations
-    const promptArtifacts = {
-        diagnosticMarkdown: sop01Content.sop01DiagnosticMarkdown,
-        aiLeverageMarkdown: sop01Content.sop01AiLeverageMarkdown,
-        roadmapSkeletonMarkdown: sop01Content.sop01RoadmapSkeletonMarkdown,
-        discoveryQuestionsMarkdown: sop01Content.sop01DiscoveryQuestionsMarkdown,
-    };
-
-    const derivedInventory: SelectedInventoryTicket[] = extractInventoryFromArtifacts(promptArtifacts);
-
-    if (derivedInventory.length === 0) {
-        console.warn(`[DiagnosticIngestion] No inventory items extracted from artifacts for tenant ${tenantId}.`);
-    }
-
-    const systemPrompt = buildDiagnosticToTicketsPrompt(
-        diagnosticMap,
-        promptArtifacts,
-        diagnosticMap.firmName || 'Tenant Firm',
-        diagnosticMap.firmSize || 'Small',
-        diagnosticMap.employeeCount || 10,
-        new Date(),
-        derivedInventory
-    );
-
-    // 3. Model Call (gpt-4-turbo-preview)
-    try {
-        const response = await openai.chat.completions.create({
-            model: 'gpt-4-turbo-preview',
-            messages: [
-                { role: 'system', content: systemPrompt },
-                { role: 'user', content: "Generate the ticket pack JSON." }
-            ],
-            response_format: { type: 'json_object' }
-        });
-
-        const content = response.choices[0]?.message?.content;
-        if (!content) throw new Error("No content from OpenAI Ticket Architect");
-
-        // 4. Parse + Validate
-        const parsed = JSON.parse(content);
-        if (!parsed.tickets || !Array.isArray(parsed.tickets)) {
-            throw new Error('TICKET_ARCHITECT_INVALID_OUTPUT: Response missing "tickets" array');
-        }
-
-        // Strict Field Validation
-        tickets = parsed.tickets.map((t: any, idx: number) => {
-            if (!t.title || !t.description || !t.ghl_implementation || !t.roi_notes) {
-                throw new Error(`TICKET_ARCHITECT_INVALID_OUTPUT: Ticket validation failed at index ${idx}. Missing required fields.`);
-            }
-            return t; // Valid
-        });
-
-    } catch (error) {
-        // Fail-closed
-        console.error('[DiagnosticIngestion] Ticket Architect Failure:', error);
-        throw error; // Re-throw to ensure 500/422 propagates
->>>>>>> 1e46cab (chore: lock executive brief render + pdf contracts)
     }
 
     // 5. Persist Atomically (Delete + Insert)
@@ -226,10 +128,6 @@ export async function ingestDiagnostic(diagnosticMap: any, sop01Content: Sop01Ou
                 tier: t.tier as any,
                 sprint: 1,
                 timeEstimateHours: t.time_estimate_hours || 4,
-<<<<<<< HEAD
-=======
-                ticketOrigin: 'agentic',
->>>>>>> 1e46cab (chore: lock executive brief render + pdf contracts)
 
                 // Rich Fields (Validated)
                 ghlImplementation: t.ghl_implementation,
@@ -260,7 +158,6 @@ export async function ingestDiagnostic(diagnosticMap: any, sop01Content: Sop01Ou
 }
 
 /**
-<<<<<<< HEAD
  * Core Ticket Generation Logic (Reuse for Stage 6)
  * Generates tickets from SOP-01 artifacts using the legacy prompt.
  * Does NOT persist to DB.
@@ -351,15 +248,15 @@ export async function generateRawTickets(
 
     // 1. Normalize Artifacts & Strict Validation
     // We handle both raw artifact objects (new) and legacy strings (backward compat)
-    const diagInfo = getArtifactRawText(artifacts.companyDiagnosticMap || artifacts.diagnosticMap);
-    const aiInfo = getArtifactRawText(artifacts.aiLeverageMap || artifacts.aiLeverageMap);
-    const skeletonInfo = getArtifactRawText(artifacts.roadmapSkeleton || artifacts.roadmapSkeleton);
-    const discoveryInfo = getArtifactRawText(artifacts.discoveryCallQuestions || artifacts.discoveryQuestions);
+    const diagInfo = getArtifactRawText(artifacts.sop01DiagnosticMarkdown || artifacts.companyDiagnosticMap);
+    const aiInfo = getArtifactRawText(artifacts.sop01AiLeverageMarkdown || artifacts.aiLeverageMap);
+    const skeletonInfo = getArtifactRawText(artifacts.sop01RoadmapSkeletonMarkdown || artifacts.roadmapSkeleton);
+    const discoveryInfo = getArtifactRawText(artifacts.sop01DiscoveryQuestionsMarkdown || artifacts.discoveryCallQuestions);
 
     // Standardized Logging (Truth Source Assertion)
     console.log(`[DiagnosticIngestion] DiagnosticMap artifact=${artifacts.diagnosticMap?.id || '?'} type=DIAGNOSTIC_MAP source=${diagInfo.source} rawLength=${diagInfo.length} reason=${diagInfo.reason || 'ok'}`);
-    console.log(`[DiagnosticIngestion] AiLeverage artifact=${artifacts.aiLeverageMap?.id || '?'} type=AI_LEVERAGE_MAP source=${aiInfo.source} rawLength=${aiInfo.length} reason=${aiInfo.reason || 'ok'}`);
-    console.log(`[DiagnosticIngestion] Skeleton artifact=${artifacts.roadmapSkeleton?.id || '?'} type=ROADMAP_SKELETON source=${skeletonInfo.source} rawLength=${skeletonInfo.length} reason=${skeletonInfo.reason || 'ok'}`);
+    console.log(`[DiagnosticIngestion] AiLeverage artifact=${artifacts.sop01AiLeverageMarkdown?.id || '?'} type=AI_LEVERAGE_MAP source=${aiInfo.source} rawLength=${aiInfo.length} reason=${aiInfo.reason || 'ok'}`);
+    console.log(`[DiagnosticIngestion] Skeleton artifact=${artifacts.sop01RoadmapSkeletonMarkdown?.id || '?'} type=ROADMAP_SKELETON source=${skeletonInfo.source} rawLength=${skeletonInfo.length} reason=${skeletonInfo.reason || 'ok'}`);
     console.log(`[DiagnosticIngestion] Discovery artifact=${artifacts.discoveryQuestions?.id || '?'} type=DISCOVERY_QUESTIONS source=${discoveryInfo.source} rawLength=${discoveryInfo.length} reason=${discoveryInfo.reason || 'ok'}`);
 
     if (diagInfo.length === 0 || aiInfo.length === 0 || skeletonInfo.length === 0 || discoveryInfo.length === 0) {
@@ -376,15 +273,15 @@ export async function generateRawTickets(
     const promptArtifacts = {
         diagnosticMarkdown: diagInfo.raw,
         aiLeverageMarkdown: aiInfo.raw,
-        roadmapSkeletonMarkdown: skeletonInfo.raw,
+        sop01RoadmapSkeletonMarkdown: skeletonInfo.raw,
         discoveryQuestionsMarkdown: discoveryInfo.raw,
     };
 
     const derivedInventory: SelectedInventoryTicket[] = extractInventoryFromArtifacts({
-        companyDiagnosticMap: diagInfo.raw,
-        aiLeverageMap: aiInfo.raw,
-        roadmapSkeleton: skeletonInfo.raw,
-        discoveryCallQuestions: discoveryInfo.raw.split('\n\n'),
+        sop01DiagnosticMarkdown: diagInfo.raw,
+        sop01AiLeverageMarkdown: aiInfo.raw,
+        sop01RoadmapSkeletonMarkdown: skeletonInfo.raw,
+        sop01DiscoveryQuestionsMarkdown: discoveryInfo.raw,
     });
 
     // Final Extraction Proof
@@ -395,8 +292,8 @@ export async function generateRawTickets(
         throw new InventoryEmptyError({
             artifactIds: [
                 artifacts.diagnosticMap?.id || artifacts.sop01DiagnosticMarkdown?.id,
-                artifacts.aiLeverageMap?.id || artifacts.sop01AiLeverageMarkdown?.id,
-                artifacts.roadmapSkeleton?.id || artifacts.sop01RoadmapSkeletonMarkdown?.id,
+                artifacts.sop01AiLeverageMarkdown?.id || artifacts.sop01AiLeverageMarkdown?.id,
+                artifacts.sop01RoadmapSkeletonMarkdown?.id || artifacts.sop01RoadmapSkeletonMarkdown?.id,
                 artifacts.discoveryQuestions?.id || artifacts.sop01DiscoveryQuestionsMarkdown?.id
             ].filter(Boolean),
             countsByArtifactType: {
@@ -499,7 +396,7 @@ export function getArtifactRawText(artifact: any): { raw: string; source: string
 export function extractInventoryFromArtifacts(sop01Content: Sop01Outputs): SelectedInventoryTicket[] {
     const rawInventory: SelectedInventoryTicket[] = [];
 
-    const raw = sop01Content.roadmapSkeleton || '';
+    const raw = sop01Content.sop01RoadmapSkeletonMarkdown || '';
     const lines = raw.split('\n');
     let currentSprint = 30;
 
@@ -532,34 +429,10 @@ export function extractInventoryFromArtifacts(sop01Content: Sop01Outputs): Selec
 
         const pMatch = line.match(phaseRegex);
         if (pMatch) {
-=======
- * Extracts implied inventory items from the SOP-01 "Roadmap Skeleton" or "AI Leverage Map"
- * to serve as the ground truth "Selected Inventory" for the prompt.
- */
-function extractInventoryFromArtifacts(sop01Content: any): SelectedInventoryTicket[] {
-    const inventory: SelectedInventoryTicket[] = [];
-
-    // Naive Extraction Strategy:
-    // Look for Headers in Roadmap Skeleton that look like "Phase X: [System Name]"
-    // Or bullet points in AI Leverage Map.
-
-    const raw = sop01Content.sop01RoadmapSkeletonMarkdown || '';
-    const lines = raw.split('\n');
-    let currentSprint = 30;
-
-    const phaseRegex = /Phase (\d+): (.*)/i;
-    const systemRegex = /\*\*System\*\*: (.*)/i;
-
-    for (const line of lines) {
-        const pMatch = line.match(phaseRegex);
-        if (pMatch) {
-            // infer sprint from phase? Phase 1 = 30, Phase 2 = 60
->>>>>>> 1e46cab (chore: lock executive brief render + pdf contracts)
             const phaseNum = parseInt(pMatch[1], 10);
             currentSprint = (phaseNum * 30) as any;
         }
 
-<<<<<<< HEAD
         if (cleanTitle && cleanTitle.length >= 5) {
             rawInventory.push({
                 inventoryId: `INV-DERIVED-${createHash('sha1').update(cleanTitle.toLowerCase().trim()).digest('hex').substring(0, 4)}`,
@@ -568,19 +441,6 @@ function extractInventoryFromArtifacts(sop01Content: any): SelectedInventoryTick
                 valueCategory: 'Efficiency',
                 ghlComponents: [],
                 description: `Implementation of ${cleanTitle} as defined in roadmap.`,
-=======
-        const sMatch = line.match(systemRegex);
-        if (sMatch) {
-            const sysName = sMatch[1].trim();
-            // Add as inventory item
-            inventory.push({
-                inventoryId: `INV-DERIVED-${nanoid(4)}`,
-                titleTemplate: sysName,
-                category: 'Implied',
-                valueCategory: 'Efficiency',
-                ghlComponents: [],
-                description: `Implementation of ${sysName} as defined in roadmap.`,
->>>>>>> 1e46cab (chore: lock executive brief render + pdf contracts)
                 implementationStatus: 'production-ready',
                 tier: 'core',
                 sprint: currentSprint as any
@@ -588,7 +448,6 @@ function extractInventoryFromArtifacts(sop01Content: any): SelectedInventoryTick
         }
     }
 
-<<<<<<< HEAD
     // Deterministic Ordering & Case-Insensitive Deduplication
     const seen = new Set<string>();
     const inventory: SelectedInventoryTicket[] = [];
@@ -606,285 +465,3 @@ function extractInventoryFromArtifacts(sop01Content: any): SelectedInventoryTick
 
     return inventory;
 }
-=======
-import { db } from '../db';
-import { sopTickets } from '../db/schema';
-import { nanoid } from 'nanoid';
-import { OpenAI } from 'openai';
-import { buildDiagnosticToTicketsPrompt, SelectedInventoryTicket } from '../trustagent/prompts/diagnosticToTickets';
-import { eq, and } from 'drizzle-orm';
-import { Sop01Outputs } from './sop01Engine';
-
-const openai = new OpenAI({
-    apiKey: process.env.OPENAI_API_KEY
-});
-
-interface ParsedTicket {
-    title: string;
-    description: string;
-    category: string;
-    tier: string;
-    ghl_implementation?: string;
-    implementation_steps?: string[];
-    success_metric?: string;
-    roi_notes?: string;
-    time_estimate_hours?: number;
-}
-
-export class ArtifactNotFoundError extends Error {
-    constructor(public prerequisites: {
-        hasDiagnosticMap: boolean;
-        hasAiLeverageMap: boolean;
-        hasRoadmapSkeleton: boolean;
-        hasDiscoveryQuestions: boolean;
-    }) {
-        super('SOP01_ARTIFACTS_NOT_FOUND');
-        this.name = 'ArtifactNotFoundError';
-    }
-}
-
-export async function ingestDiagnostic(diagnosticMap: any, sop01Content: Sop01Outputs): Promise<{
-    ticketCount: number;
-    roadmapSectionCount: number;
-    diagnosticId?: string;
-    assistantProvisioned?: boolean;
-}> {
-    const start = Date.now();
-    const tenantId = diagnosticMap.tenantId; // Expected to be present
-    const diagnosticId = `diag_${nanoid()}`;
-
-    // 1. Locate Truth Source / Strict Validation
-    const hasDiagnosticMap = !!sop01Content.sop01DiagnosticMarkdown;
-    const hasAiLeverageMap = !!sop01Content.sop01AiLeverageMarkdown;
-    const hasRoadmapSkeleton = !!sop01Content.sop01RoadmapSkeletonMarkdown;
-    const hasDiscoveryQuestions = !!sop01Content.sop01DiscoveryQuestionsMarkdown;
-
-    if (!hasDiagnosticMap || !hasAiLeverageMap || !hasRoadmapSkeleton || !hasDiscoveryQuestions) {
-        console.error(`[DiagnosticIngestion] Missing required SOP-01 artifacts for tenant ${tenantId}`);
-        throw new ArtifactNotFoundError({
-            hasDiagnosticMap,
-            hasAiLeverageMap,
-            hasRoadmapSkeleton,
-            hasDiscoveryQuestions
-        });
-    }
-
-    let tickets: ParsedTicket[] = [];
-
-    // 2. Prompt Construction (Strictly derived from artifacts)
-    // Map canonical fields to prompt expectations
-    const promptArtifacts = {
-        diagnosticMarkdown: sop01Content.sop01DiagnosticMarkdown,
-        aiLeverageMarkdown: sop01Content.sop01AiLeverageMarkdown,
-        roadmapSkeletonMarkdown: sop01Content.sop01RoadmapSkeletonMarkdown,
-        discoveryQuestionsMarkdown: sop01Content.sop01DiscoveryQuestionsMarkdown,
-    };
-
-    const derivedInventory: SelectedInventoryTicket[] = extractInventoryFromArtifacts(promptArtifacts);
-
-    if (derivedInventory.length === 0) {
-        console.warn(`[DiagnosticIngestion] No inventory items extracted from artifacts for tenant ${tenantId}.`);
-    }
-
-    const systemPrompt = buildDiagnosticToTicketsPrompt(
-        diagnosticMap,
-        promptArtifacts,
-        diagnosticMap.firmName || 'Tenant Firm',
-        diagnosticMap.firmSize || 'Small',
-        diagnosticMap.employeeCount || 10,
-        new Date(),
-        derivedInventory
-    );
-
-    // 3. Model Call (gpt-4-turbo-preview)
-    try {
-        const response = await openai.chat.completions.create({
-            model: 'gpt-4-turbo-preview',
-            messages: [
-                { role: 'system', content: systemPrompt },
-                { role: 'user', content: "Generate the ticket pack JSON." }
-            ],
-            response_format: { type: 'json_object' }
-        });
-
-        const content = response.choices[0]?.message?.content;
-        if (!content) throw new Error("No content from OpenAI Ticket Architect");
-
-        // 4. Parse + Validate
-        const parsed = JSON.parse(content);
-        if (!parsed.tickets || !Array.isArray(parsed.tickets)) {
-            throw new Error('TICKET_ARCHITECT_INVALID_OUTPUT: Response missing "tickets" array');
-        }
-
-        // Strict Field Validation
-        tickets = parsed.tickets.map((t: any, idx: number) => {
-            if (!t.title || !t.description || !t.ghl_implementation || !t.roi_notes) {
-                throw new Error(`TICKET_ARCHITECT_INVALID_OUTPUT: Ticket validation failed at index ${idx}. Missing required fields.`);
-            }
-            return t; // Valid
-        });
-
-    } catch (error) {
-        // Fail-closed
-        console.error('[DiagnosticIngestion] Ticket Architect Failure:', error);
-        throw error; // Re-throw to ensure 500/422 propagates
-    }
-
-    // 5. Persist Atomically (Delete + Insert)
-    await db.transaction(async (tx) => {
-        // Idempotency: Remove any existing tickets for this diagnostic session (if re-running)
-        // Note: The previous logic generated a NEW diagnosticId every time. 
-        // If we want actual idempotency for a *Diagnostic Session*, we should reuse the diagnosticId passed in.
-        // However, standard flow here implies a "new ingestion event". 
-        // To be safe against partials, we just insert cleanly since ID is new.
-        // But per spec "Idempotent: re-ingesting... delete+replace".
-        // Since we gen a NEW ID here `const diagnosticId = ...`, strict idempotency applies to *this specific execution* failing halfway.
-        // Transaction handles that.
-
-        // If reusing diagnostic ID was intended, it should be passed in. 
-        // Assuming this function IS the session starter, new ID is correct. 
-
-        if (tickets.length > 0) {
-            const ticketInserts = tickets.map((t, idx) => ({
-                id: nanoid(),
-                tenantId,
-                diagnosticId,
-                ticketId: `T-${idx + 1}`,
-                title: t.title.substring(0, 255),
-                description: t.description,
-                category: t.category,
-                status: 'proposed',
-                approved: false, // Critical: Moderation required
-                priority: 'medium',
-                tier: t.tier as any,
-                sprint: 1,
-                timeEstimateHours: t.time_estimate_hours || 4,
-                ticketOrigin: 'agentic',
-
-                // Rich Fields (Validated)
-                ghlImplementation: t.ghl_implementation,
-                implementationSteps: t.implementation_steps ? JSON.stringify(t.implementation_steps) : null,
-                successMetric: t.success_metric || 'Defined during kickoff',
-                roiNotes: t.roi_notes,
-
-                projectedHoursSavedWeekly: 0,
-                projectedLeadsRecoveredMonthly: 0,
-                costEstimate: 0,
-                createdAt: new Date(),
-                updatedAt: new Date()
-            }));
-
-            await tx.insert(sopTickets).values(ticketInserts);
-        }
-    });
-
-    // 6. Observability
-    console.log(`[TICKET_ARCHITECT] ${tenantId} ${diagnosticId} ${tickets.length} gpt-4-turbo-preview ${Date.now() - start}ms`);
-
-    return {
-        ticketCount: tickets.length,
-        roadmapSectionCount: 0,
-        diagnosticId,
-        assistantProvisioned: true
-    };
-}
-
-/**
- * Extracts implied inventory items from the SOP-01 "Roadmap Skeleton" or "AI Leverage Map"
- * to serve as the ground truth "Selected Inventory" for the prompt.
- */
-function extractInventoryFromArtifacts(sop01Content: any): SelectedInventoryTicket[] {
-    const inventory: SelectedInventoryTicket[] = [];
-
-    // Naive Extraction Strategy:
-    // Look for Headers in Roadmap Skeleton that look like "Phase X: [System Name]"
-    // Or bullet points in AI Leverage Map.
-
-    const raw = sop01Content.sop01RoadmapSkeletonMarkdown || '';
-    const lines = raw.split('\n');
-    let currentSprint = 30;
-
-    const phaseRegex = /Phase (\d+): (.*)/i;
-    const systemRegex = /\*\*System\*\*: (.*)/i;
-
-    for (const line of lines) {
-        const pMatch = line.match(phaseRegex);
-        if (pMatch) {
-            // infer sprint from phase? Phase 1 = 30, Phase 2 = 60
-            const phaseNum = parseInt(pMatch[1], 10);
-            currentSprint = (phaseNum * 30) as any;
-        }
-
-        const sMatch = line.match(systemRegex);
-        if (sMatch) {
-            const sysName = sMatch[1].trim();
-            // Add as inventory item
-            inventory.push({
-                inventoryId: `INV-DERIVED-${nanoid(4)}`,
-                titleTemplate: sysName,
-                category: 'Implied',
-                valueCategory: 'Efficiency',
-                ghlComponents: [],
-                description: `Implementation of ${sysName} as defined in roadmap.`,
-                implementationStatus: 'production-ready',
-                tier: 'core',
-                sprint: currentSprint as any
-            });
-        }
-    }
-
-    // Fallback: If roadmap skeleton didn't parse well, try AI Leverage Map simple bullets
-    if (inventory.length === 0 && sop01Content.sop01AiLeverageMarkdown) {
-        const levLines = sop01Content.sop01AiLeverageMarkdown.split('\n');
-        const bulletRegex = /^\s*-\s*\*\*(.*?)\*\*/;
-
-        for (const l of levLines) {
-            const bMatch = l.match(bulletRegex);
-            if (bMatch) {
-                inventory.push({
-                    inventoryId: `INV-DERIVED-${nanoid(4)}`,
-                    titleTemplate: bMatch[1].trim(),
-                    category: 'Growth',
-                    valueCategory: 'Revenue',
-                    ghlComponents: [],
-                    description: 'Derived opportunity from AI Leverage Map',
-                    implementationStatus: 'production-ready',
-                    tier: 'recommended',
-                    sprint: 30
-                });
-            }
-        }
-    }
-
-    // Limit to reasonable pack size to avoid token overflow
-    return inventory.slice(0, 15);
-}
->>>>>>> 02e8d03 (feat: executive brief approval, state sync, and pdf delivery pipeline)
-=======
-    // Fallback: If roadmap skeleton didn't parse well, try AI Leverage Map simple bullets
-    if (inventory.length === 0 && sop01Content.sop01AiLeverageMarkdown) {
-        const levLines = sop01Content.sop01AiLeverageMarkdown.split('\n');
-        const bulletRegex = /^\s*-\s*\*\*(.*?)\*\*/;
-
-        for (const l of levLines) {
-            const bMatch = l.match(bulletRegex);
-            if (bMatch) {
-                inventory.push({
-                    inventoryId: `INV-DERIVED-${nanoid(4)}`,
-                    titleTemplate: bMatch[1].trim(),
-                    category: 'Growth',
-                    valueCategory: 'Revenue',
-                    ghlComponents: [],
-                    description: 'Derived opportunity from AI Leverage Map',
-                    implementationStatus: 'production-ready',
-                    tier: 'recommended',
-                    sprint: 30
-                });
-            }
-        }
-    }
-
-    // Limit to reasonable pack size to avoid token overflow
-    return inventory.slice(0, 15);
-}
->>>>>>> 1e46cab (chore: lock executive brief render + pdf contracts)
diff --git a/backend/src/services/sop01Persistence.ts b/backend/src/services/sop01Persistence.ts
index ea2a78c..fdee052 100644
--- a/backend/src/services/sop01Persistence.ts
+++ b/backend/src/services/sop01Persistence.ts
@@ -1,7 +1,3 @@
-<<<<<<< HEAD
-<<<<<<< HEAD
-=======
->>>>>>> 1e46cab (chore: lock executive brief render + pdf contracts)
 import { db } from '../db';
 import { tenantDocuments, tenants } from '../db/schema';
 import { eq, and } from 'drizzle-orm';
@@ -18,17 +14,6 @@ export async function persistSop01OutputsForTenant(tenantId: string, outputs: So
 
     // 1. Strict Validation: All 4 must exist
     const requiredKeys: (keyof Sop01Outputs)[] = [
-<<<<<<< HEAD
-        'companyDiagnosticMap',
-        'aiLeverageMap',
-        'discoveryCallQuestions',
-        'roadmapSkeleton'
-    ];
-
-    for (const key of requiredKeys) {
-        const val = outputs[key];
-        if (!val || (Array.isArray(val) && val.length === 0) || (typeof val === 'string' && val.trim() === '')) {
-=======
         'sop01DiagnosticMarkdown',
         'sop01AiLeverageMarkdown',
         'sop01DiscoveryQuestionsMarkdown',
@@ -36,8 +21,8 @@ export async function persistSop01OutputsForTenant(tenantId: string, outputs: So
     ];
 
     for (const key of requiredKeys) {
-        if (!outputs[key] || typeof outputs[key] !== 'string' || outputs[key].trim() === '') {
->>>>>>> 1e46cab (chore: lock executive brief render + pdf contracts)
+        const val = outputs[key];
+        if (!val || (Array.isArray(val) && val.length === 0) || (typeof val === 'string' && val.trim() === '')) {
             throw new Error(`SOP01_PERSIST_FAILED: Missing mandatory artifact: ${key}`);
         }
     }
@@ -52,48 +37,28 @@ export async function persistSop01OutputsForTenant(tenantId: string, outputs: So
     const artifacts = [
         {
             type: 'DIAGNOSTIC_MAP',
-<<<<<<< HEAD
             title: 'Company Diagnostic Map',
-            content: outputs.companyDiagnosticMap,
-=======
-            title: 'SOP-01: Company Diagnostic Map',
             content: outputs.sop01DiagnosticMarkdown,
->>>>>>> 1e46cab (chore: lock executive brief render + pdf contracts)
             filename: 'sop01_diagnostic_map.md'
         },
         {
             type: 'AI_LEVERAGE_MAP',
-<<<<<<< HEAD
             title: 'AI Leverage & Opportunity Map',
-            content: outputs.aiLeverageMap,
-=======
-            title: 'SOP-01: AI Leverage Map',
             content: outputs.sop01AiLeverageMarkdown,
->>>>>>> 1e46cab (chore: lock executive brief render + pdf contracts)
             filename: 'sop01_ai_leverage_map.md'
         },
         {
             type: 'ROADMAP_SKELETON',
-<<<<<<< HEAD
             title: 'Strategic Roadmap Skeleton',
-            content: outputs.roadmapSkeleton,
-=======
-            title: 'SOP-01: Roadmap Skeleton',
             content: outputs.sop01RoadmapSkeletonMarkdown,
->>>>>>> 1e46cab (chore: lock executive brief render + pdf contracts)
             filename: 'sop01_roadmap_skeleton.md'
         },
         {
             type: 'DISCOVERY_QUESTIONS',
-<<<<<<< HEAD
             title: 'Discovery Call Preparation Questions',
-            content: Array.isArray(outputs.discoveryCallQuestions)
-                ? outputs.discoveryCallQuestions.join('\n\n')
-                : outputs.discoveryCallQuestions,
-=======
-            title: 'SOP-01: Discovery Call Questions',
-            content: outputs.sop01DiscoveryQuestionsMarkdown,
->>>>>>> 1e46cab (chore: lock executive brief render + pdf contracts)
+            content: Array.isArray(outputs.sop01DiscoveryQuestionsMarkdown)
+                ? outputs.sop01DiscoveryQuestionsMarkdown.join('\n\n')
+                : outputs.sop01DiscoveryQuestionsMarkdown,
             filename: 'sop01_discovery_questions.md'
         }
     ];
@@ -115,10 +80,7 @@ export async function persistSop01OutputsForTenant(tenantId: string, outputs: So
                     filePath: `db://sop01/${artifact.type.toLowerCase()}.md`,
                     fileSize: Buffer.byteLength(artifact.content, 'utf-8'),
                     mimeType: 'text/markdown',
-<<<<<<< HEAD
                     isPublic: true,
-=======
->>>>>>> 1e46cab (chore: lock executive brief render + pdf contracts)
                     updatedAt: new Date()
                 };
 
@@ -143,111 +105,3 @@ export async function persistSop01OutputsForTenant(tenantId: string, outputs: So
 
     console.log('[SOP-01 Persistence] Completed successfully.');
 }
-<<<<<<< HEAD
-=======
-import { db } from '../db';
-import { tenantDocuments, tenants } from '../db/schema';
-import { eq, and } from 'drizzle-orm';
-import { Sop01Outputs } from './sop01Engine';
-
-/**
- * Persist SOP-01 artifacts to tenant_documents.
- * Category: 'sop_output'
- * SOP Number: 'SOP-01'
- * Stable Output Numbers for identification.
- */
-export async function persistSop01OutputsForTenant(tenantId: string, outputs: Sop01Outputs): Promise<void> {
-    console.log('[SOP-01 Persistence] Persisting outputs for tenant:', tenantId);
-
-    // 1. Strict Validation: All 4 must exist
-    const requiredKeys: (keyof Sop01Outputs)[] = [
-        'sop01DiagnosticMarkdown',
-        'sop01AiLeverageMarkdown',
-        'sop01DiscoveryQuestionsMarkdown',
-        'sop01RoadmapSkeletonMarkdown'
-    ];
-
-    for (const key of requiredKeys) {
-        if (!outputs[key] || typeof outputs[key] !== 'string' || outputs[key].trim() === '') {
-            throw new Error(`SOP01_PERSIST_FAILED: Missing mandatory artifact: ${key}`);
-        }
-    }
-
-    const [tenant] = await db.select().from(tenants).where(eq(tenants.id, tenantId)).limit(1);
-    if (!tenant) {
-        throw new Error(`Tenant not found: ${tenantId}`);
-    }
-
-    const ownerUserId = tenant.ownerUserId;
-
-    const artifacts = [
-        {
-            type: 'DIAGNOSTIC_MAP',
-            title: 'SOP-01: Company Diagnostic Map',
-            content: outputs.sop01DiagnosticMarkdown,
-            filename: 'sop01_diagnostic_map.md'
-        },
-        {
-            type: 'AI_LEVERAGE_MAP',
-            title: 'SOP-01: AI Leverage Map',
-            content: outputs.sop01AiLeverageMarkdown,
-            filename: 'sop01_ai_leverage_map.md'
-        },
-        {
-            type: 'ROADMAP_SKELETON',
-            title: 'SOP-01: Roadmap Skeleton',
-            content: outputs.sop01RoadmapSkeletonMarkdown,
-            filename: 'sop01_roadmap_skeleton.md'
-        },
-        {
-            type: 'DISCOVERY_QUESTIONS',
-            title: 'SOP-01: Discovery Call Questions',
-            content: outputs.sop01DiscoveryQuestionsMarkdown,
-            filename: 'sop01_discovery_questions.md'
-        }
-    ];
-
-    try {
-        await db.transaction(async (tx) => {
-            for (const artifact of artifacts) {
-                const docData = {
-                    tenantId,
-                    ownerUserId,
-                    filename: artifact.filename,
-                    originalFilename: artifact.filename,
-                    title: artifact.title,
-                    description: `AI-generated ${artifact.title} (SOP-01)`,
-                    category: 'sop_output',
-                    sopNumber: 'SOP-01',
-                    outputNumber: artifact.type,
-                    content: artifact.content,
-                    filePath: `db://sop01/${artifact.type.toLowerCase()}.md`,
-                    fileSize: Buffer.byteLength(artifact.content, 'utf-8'),
-                    mimeType: 'text/markdown',
-                    updatedAt: new Date()
-                };
-
-                // Use upsert logic via onConflictDoUpdate
-                await tx.insert(tenantDocuments)
-                    .values({
-                        ...docData,
-                        createdAt: new Date()
-                    })
-                    .onConflictDoUpdate({
-                        target: [tenantDocuments.tenantId, tenantDocuments.category, tenantDocuments.sopNumber, tenantDocuments.outputNumber],
-                        set: docData
-                    });
-
-                console.log(`  - Persisted artifact: ${artifact.type}`);
-            }
-        });
-    } catch (err: any) {
-        console.error('[SOP-01 Persistence] Transaction failed:', err);
-        throw new Error(`SOP01_PERSIST_FAILED: ${err.message}`);
-    }
-
-    console.log('[SOP-01 Persistence] Completed successfully.');
-}
->>>>>>> 02e8d03 (feat: executive brief approval, state sync, and pdf delivery pipeline)
-=======
->>>>>>> 1e46cab (chore: lock executive brief render + pdf contracts)
